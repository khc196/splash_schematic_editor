<!DOCTYPE html>
<html>
<head>
  <title>RTOS Spash Schematic Editor</title>
  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Copyright 1998-2019 by Northwoods Software Corporation. -->

  <script src="../libraries/Gojs/release/go.js" type="text/javascript"/></script>
  <script src="../libraries/Gojs/extensions/Figures.js" type="text/javascript"></script>
  <script src="../libraries/Gojs/extensions/Templates.js" type="text/javascript">	</script>
  <script src="../libraries/Gojs/extensions/ResizeMultipleTool.js" type="text/javascript"></script>
  <script src="../libraries/Gojs/extensions/PortShiftingTool.js" type="text/javascript"></script>
  <script src="../libraries/Gojs/extensions/DrawCommandHandler.js"></script>
  <script src="../libraries/Gojs/extensions/GuidedDraggingTool.js"></script>
  <script src="../libraries/Gojs/extensions/DataInspector.js"></script>
  <script src="../libraries/Gojs/extensions/RealtimeDragSelectingTool.js"></script>

  <script src="../libraries/jquery-3.4.1.js" type="text/javascript"></script>
  <script src="../libraries/ResizeSensor.js" type="text/javascript"></script>
  <script src="../libraries/FileSaver.js" type="text/javascript"></script>

  <!-- stikcy.js and rAF.js are used for implement floating palette (deprecated)-->
  <script src="../libraries/sticky/jquery.sticky.js" type="text/javascript"></script>
  <script src="../libraries/rAF.js" type="text/javascript"></script>


  <link rel="stylesheet" href="../css/EditorStyle.css" type="text/css">
  <link rel="stylesheet" href="../libraries/Gojs/assets/css/jquery-ui.min.css" />
  <script src="../libraries/Gojs/assets/js/jquery.min.js"></script>
  <script src="../libraries/Gojs/assets/js/jquery-ui.min.js"></script>
  
  <script id="code">
            // build unit layout
            {
        function CustomLayout() {
            go.Layout.call(this);
        }

        go.Diagram.inherit(CustomLayout, go.Layout);

        CustomLayout.prototype.doLayout = function(coll) {
            coll = this.collectParts(coll);

            var supers = new go.Set(/*go.Node*/);
            coll.each(function(p) {
                if (p instanceof go.Node && p.category === "buildUnit") supers.add(p);
            });

            function membersOf(sup, diag) {
                var set = new go.Set(/*go.Part*/);
                var arr = sup.data._members;
                for (var i = 0; i < arr.length; i++) {
                var d = arr[i];
                set.add(diag.findNodeForData(d));
                }
                return set;
            }

            function isReady(sup, supers, diag) {
                var arr = sup.data._members;
                for (var i = 0; i < arr.length; i++) {
                    var d = arr[i];
                    if (d.category === "buildUnit") continue;
                    var n = diag.findNodeForData(d);
                    if (supers.has(n)) return false;
                }
                return true;
            }
            // implementations of doLayout that do not make use of a LayoutNetwork
            // need to perform their own transactions
            this.diagram.startTransaction("Custom Layout");
            while (supers.count > 0) {
                var ready = null;
                var it = supers.iterator;
                while (it.next()) {
                    if (isReady(it.value, supers, this.diagram)) {
                        ready = it.value;
                        break;
                    }
                }
                supers.remove(ready);
                var b = this.diagram.computePartsBounds(membersOf(ready, this.diagram));
                ready.location = b.position;
                var body = ready.findObject("BODY");
                if (body) { 
                    body.desiredSize = b.size;
                }
            }
            this.diagram.commitTransaction("Custom Layout");
        };
        // end CustomLayout


        // Define a custom DraggingTool
        function CustomDraggingTool() {
            go.DraggingTool.call(this);
        }
        go.Diagram.inherit(CustomDraggingTool, go.DraggingTool);

        CustomDraggingTool.prototype.moveParts = function(parts, offset, check) {
            go.DraggingTool.prototype.moveParts.call(this, parts, offset, check);
            this.diagram.layoutDiagram(true);
        };

        CustomDraggingTool.prototype.computeEffectiveCollection = function(parts) {
            var coll = new go.Set(/*go.Part*/).addAll(parts);
            var tool = this;
            parts.each(function(p) {
                tool.walkSubTree(p, coll);
            });
            return go.DraggingTool.prototype.computeEffectiveCollection.call(this, coll);
        };

        // Find other attached nodes.
        CustomDraggingTool.prototype.walkSubTree = function(sup, coll) {
            if (sup === null) return;
            coll.add(sup);
            if (sup.category !== "buildUnit") return;
            // recurse through this super state's members
            var model = this.diagram.model;
            var mems = sup.data._members;
            if (mems) {
                for (var i = 0; i < mems.length; i++) {
                    var mdata = mems[i];
                    this.walkSubTree(this.diagram.findNodeForData(mdata), coll);
                }
            }
        };
        // end CustomDraggingTool class
    }
    var red = "orangered";  // 0 or false
    var green = "forestgreen";  // 1 or true

    var init_instance;
    var myDiagram, palette, myDiagram_buildUnit, myDiagram_buildUnit_selectionPane, myDiagram_buildUnit_selectionPaneTitle, myDiagram_sthread_component, myDiagram_sthread_sthread, myOverview, myOverview_bulidUnit;
    function init() {

        var externalDroppedObjectName = "NONE";
        var internalSelectedObjectName = "NONE";

        var $ = go.GraphObject.make;  // for conciseness in defining templates
        myDiagram =
            $(go.Diagram, "SplashCanvas",  // create a new Diagram in the HTML DIV element "SplashCanvas"
            {
                initialDocumentSpot: go.Spot.TopCenter,
                initialViewportSpot: go.Spot.TopCenter,
                draggingTool: $(CustomDraggingTool),
                layout: $(CustomLayout), 
                "undoManager.isEnabled": true,
                // commandHandler: new DrawCommandHandler(),  // defined in DrawCommandHandler.js
                // "commandHandler.archetypeGroupData": { isGroup: true, category: "OfNodes" },
                
                // resizingTool: new ResizeMultipleTool(),  // defined in ResizeMultipleTool.js
                // "resizingTool.isGridSnapEnabled" : true,
                
                "animationManager.isEnabled": false,
                // draggingTool: new GuidedDraggingTool(),  // defined in GuidedDraggingTool.js
                // "draggingTool.isGridSnapEnabled": true,  // dragged nodes will snap to a grid of 10x10 cells
                // "draggingTool.horizontalGuidelineColor": "blue",
                // "draggingTool.verticalGuidelineColor": "blue",
                // "draggingTool.centerGuidelineColor": "green",
                // "draggingTool.guidelineWidth": 1,

                
                

                // notice when the Paste command may need to be reenabled
                "ClipboardChanged": enableAll,


                // dragSelectingTool:
                // $(RealtimeDragSelectingTool,
                // { isPartialInclusion: true, delay: 175 },
                // {
                //     box: $(go.Part,  // replace the magenta box with a red one
                //     { layerName: "Tool", selectable: false },
                //     $(go.Shape,
                //         {
                //         name: "SHAPE", fill: "rgba(255,0,0,0.1)",
                //         stroke: "red", strokeWidth: 2
                //         }))
                // },
                // ),

                mouseDrop: function(e) { 
                    console.log("mouseDrop");
                    
                    finishDrop(e, null);
                },
                
                
                ExternalObjectsDropped: function(e) {
                
                    console.log("ExternalObjectsDropped()");
                    e.subject.each( function(part) 
                        {
                            externalDroppedObjectName = part.name;
                            internalSelectedObjectName = "NONE";
                            setDefaultProperty(part);
                            addDefaultPort(part);
                            inspector.inspectObject();
                            inspector2.inspectObject();
                            updateCurrentObject(part);
                            addLog("Add a new Component: "+part.name);
                            //console.log("BuildUnit is null string? "+ (part.data.BuildUnit === null) ? "true" : "false");
                        });
                },
                "ViewportBoundsChanged": function(e) {
                //let allowScroll = !e.diagram.viewportBounds.containsRect(e.diagram.documentBounds);
                // myDiagram_buildUnit_selectionPane.allowVerticalScroll = allowScroll;
                    console.log("ViewportBoundsChanged");
                },
                SelectionCopied: function(e) {
                    console.log("SelectionCopied()");
                    //e.subject.part.key = createKeyUUID();

                    e.subject.each( function(part) 
                    {
                        part.key = createKeyUUID();
                        addLog("Copy a new Component: "+part.name);
                        console.log("key:"+part.key);
                    });

                    inspector.inspectObject();
                    inspector2.inspectObject();
                    },
                    
                ClipboardPasted: function(e) {
                    console.log("ClipboardPasted()");
                    //e.subject.part.key = createKeyUUID();

                    e.subject.each( function(part) 
                    {
                        setDefaultProperty(part);
                        addDefaultPort(part);
                        inspector.inspectObject();
                        inspector2.inspectObject();
                        updateCurrentObject(part);
                        addLog("Copy a new Component: "+part.name);
                    });

                },
                
                ObjectSingleClicked: function(e) {
                    console.log("ObjectSingleClicked()");
                    var selected = e.subject.part;
                    externalDroppedObjectName = "NONE";
                    internalSelectedObjectName = selected.name;
                    console.log(selected.key);
                    console.log(selected.name);
                    //setDefaultProperty(selected);

                    updateCurrentObject(selected);
                    //relocatePort(selected);              

                    inspector.inspectObject();
                    inspector2.inspectObject();
                },

                ObjectContextClicked: function(e) {
                    console.log("ObjectContextClicked()");
                    var selected = e.subject.part;
                    externalDroppedObjectName = "NONE";
                    internalSelectedObjectName = selected.name;

                    //setDefaultProperty(selected);

                    updateCurrentObject(selected);
                    //relocatePort(selected);

                    inspector.inspectObject();
                    inspector2.inspectObject();   
                },

                ChangingSelection: function(e) {

                    //inheritBuildUnit(e);
                    console.log("ChangingSelection()");
                    // e.diagram.selection.each(function(part){
                    //     updateCurrentObject(part);              
                    // });
     
                },
                AnimationStarting: function(e) {
                    console.log("AnimationStarting()");
                },
                SelectionMoved: function(e) {
                    console.log("SelectionMoved()");
                    myDiagram_buildUnit.layout.invalidateLayout();
                },
                PartResized: function(e) {
                    console.log("PartResized()");
                },


                LinkDrawn: function(e) {
                    console.log("LinkDrawn()");
        
                    deactivateAllStreamPort(e.diagram);
                    deactivateAllEventPort(e.diagram);

                    //var selected = e.subject.part;
                    //selected.data.segArray = selected.flattenedLengths.toString();

                    inspector.inspectObject();
                    inspector2.inspectObject();
                    // myDiagram.selection.each(function(n) {
                    //     diagnodes.add(myDiagram_buildUnit_selectionPane.findNodeForData(n.data));
                    // });
                    // myDiagram_buildUnit_selectionPane.clearSelection();
                    // myDiagram_buildUnit_selectionPane.selectCollection(diagnodes);
                    myChangingSelection = false;
                },
                
                // TextEdited: function(e) {
                //   console.log("TextEdited()");

                //   var selected = e.subject.part;
                //   relocatePort(selected);

                //   inspector.inspectObject();
                //   inspector2.inspectObject();
                // },


                // ChangedSelection: function(e) {
                //   console.log("ChangedSelection()");
                //   var selected = e.subject.part;
                //   console.log(selected);

                //   inspector.inspectObject();
                //   inspector2.inspectObject();
                // },

            }); 
       
        var myChangingSelection = false;
        var myChangingModel = false;
        
        myDiagram.isModified = false;
        // var selectingTool = myDiagram.toolManager.dragSelectingTool;
        // selectingTool.doActivate = function() {
        //   go.DragSelectingTool.prototype.doActivate.call(this);    
        // }  

        // relocatePart() is relocate stream input/output port of source/sink component when there textBlock is added.
        function relocatePort(part) {
            console.log("relocatePort()");

            var it_memberParts;
            var memeber_port;

            if(part.name == "SOURCE") {
            it_memberParts = part.memberParts;
            memeber_port = it_memberParts.first()

            memeber_port.location = new go.Point(part.location.x+30, part.location.y-part.actualBounds.height/2+10);
            console.log(memeber_port.location);

            } else if(part.name == "SINK") {
            it_memberParts = part.memberParts;
            memeber_port = it_memberParts.first()

            memeber_port.location = new go.Point(part.location.x-50, part.location.y-part.actualBounds.height/2+10);

            } else if(part.name == "FUSION") {
            /*
            it_memberParts = part.memberParts;

            it_memberParts.each(function(node){
                if(node.name === "STREAM_OUTPUT_PORT") memeber_port = node;
            });
            memeber_port.location = new go.Point(part.location.x+30, part.location.y-part.actualBounds.height/2+40);
            */
            }
        }


        // Build unit code
        function inheritBuildUnit(part) {
            console.log("inheritBuildUnit()");
            var it_memeberParts;
            var memeber_port;

            // 1. factory
            if(part.name === "FACTORY") {          
            it_memeberParts = part.memberParts;
            // 1-1. factory, delegation port and atmoic component
            if(!notAssigned_buildUnit(part.data.buildUnit)) {
                it_memeberParts.each(function(node){
                if(node.name === "FACTORY") {
                    node.data.buildUnit = part.data.buildUnit;
                    inheritBuildUnit(node);
                }
                if(node.name === "STREAM_DELEGATION_PORT") {
                    node.data.buildUnit = part.data.buildUnit;
                }
                if(node.name === "SOURCE"
                    || node.name === "SINK"
                    || node.name === "PROCESSING"
                    || node.name === "FUSION") {
                    node.data.buildUnit = part.data.buildUnit;
                    inheritBuildUnit(node);
                }
                });
            } else {
                it_memeberParts.each(function(node){
                if(node.name === "STREAM_DELEGATION_PORT") {
                    node.data.buildUnit = undefined;
                }
                });
            }
            }

            // 2. atomic component
            if(part.name === "SOURCE"
            || part.name === "SINK"
            || part.name === "PROCESSING"
            || part.name === "FUSION") {
            it_memeberParts = part.memberParts;
            // port
            it_memeberParts.each(function(node){
                if(node.name === "STREAM_INPUT_PORT"
                || node.name === "STREAM_OUTPUT_PORT") {
                node.data.buildUnit = part.data.buildUnit;
                }
            });
            }

            // 3. channel
            var it_links;

            if(part.name === "FACTORY") {
            it_memeberParts = part.memberParts;
            it_memeberParts.each(function(node){
                if(node.name === "STREAM_DELEGATION_PORT") {
                it_links = node.findLinksConnected();
                it_links.each(function(link){
                    if(link.fromNode.data.buildUnit == link.toNode.data.buildUnit) {
                    link.data.buildUnit = link.fromNode.data.buildUnit;
                    }
                });
                }
            });
            } else if(part.name === "SOURCE"
            || part.name === "SINK"
            || part.name === "PROCESSING"
            || part.name === "FUSION") {
            it_memeberParts = part.memberParts;
            it_memeberParts.each(function(node){
                if(node.name === "STREAM_INPUT_PORT"
                || node.name === "STREAM_OUTPUT_PORT") {
                it_links = node.findLinksConnected();
                it_links.each(function(link){
                    if(link.fromNode.data.buildUnit == link.toNode.data.buildUnit) {
                    link.data.buildUnit = link.fromNode.data.buildUnit;
                    }
                });
                }
            });
            }        
        }

        // build unit
        function updatebuiilUnit(part) {
            inheritBuildUnit(part);
        }

        function updateObjectBindings(part) {
            part.UpdateTargetBindings;
        }

        function updateCurrentObject(part) {
            console.log('updateCurrentObject()');
            relocatePort(part);
            updatebuiilUnit(part);
            //inheritBuildUnit(part);
            updateObjectBindings(part);
            if(part.name == "FUSION") {
                UpdatePropertyWindow_fusionOperator(part);
            }
            if(part.name == "STREAM_INPUT_PORT") {
                if(!(part.containingGroup === null || part.containingGroup === undefined)) {         
                    if(part.containingGroup.name == "FUSION")
                    UpdatePropertyWindow_fusionOperator(part);
                }
            }
        }    

        function addDefaultPort(part) {
            var defaultPort;
            if(part.name === "SOURCE") {
                defaultPort = {
                    category: "streamPort", 
                    group: part.data.key, 
                    PORT_TYPE: "STREAM_OUTPUT_PORT",
                    loc: go.Point.stringify(new go.Point(part.location.x+30, part.location.y-part.actualBounds.height/2+10)),
                };
                myDiagram.model.addNodeData(defaultPort);  
            } else if(part.name === "SINK") {
                defaultPort = {
                    category: "streamPort", 
                    group: part.data.key, 
                    PORT_TYPE: "STREAM_INPUT_PORT",
                    loc: go.Point.stringify(new go.Point(part.location.x-50, part.location.y-part.actualBounds.height/2+10)),
                };
                myDiagram.model.addNodeData(defaultPort); 
            } else if(part.name === "FUSION") {
                defaultPort = {
                    category: "streamPort", 
                    group: part.data.key, 
                    PORT_TYPE: "STREAM_OUTPUT_PORT",
                    loc: go.Point.stringify(new go.Point(part.location.x+10, part.location.y-part.actualBounds.height/2+40)),
                };
                myDiagram.model.addNodeData(defaultPort);  
            }
        }


  		function setDefaultProperty(part) {
            console.log("setDefaultProperty()");
            var new_name = ""
            var name_count = 1;
            part.data.buildUnit = "";
            if(part.name === "PROCESSING") {
                part.data.WIDTH = 100; 
                part.data.HEIGHT = 100;
            } else if (part.name === "SOURCE") {
            } else if (part.name === "FUSION") {
                part.data.HEIGHT = 100;
                part.data.WIDTH = 40;
            } else if (part.name === "FACTORY") {
                part.data.WIDTH = 450;
                part.data.HEIGHT = 250; 
            }
            myDiagram.requestUpdate()
  		}
        function checkIfNameExists(name) {
            var exist_flag = false;
            myDiagram.nodes.each(function(node) {
                if(name == node.key) {
                    exist_flag = true;
                    return;
                }
            })
            return exist_flag;
        }
      
        myDiagram.model.makeUniqueKeyFunction = setKeyUUID;
        
        myDiagram.grid =
            $(go.Panel, "Grid",
            {
                name: "GRID",
                visible: true,
                gridCellSize: new go.Size(10, 10),
                gridOrigin: new go.Point(0, 0)
            },
            $(go.Shape, "LineH", { stroke: "lightgray", strokeWidth: 0.5, interval: 1 }),
            $(go.Shape, "LineH", { stroke: "gray", strokeWidth: 0.5, interval: 5 }),
            $(go.Shape, "LineH", { stroke: "gray", strokeWidth: 1.0, interval: 10 }),
            $(go.Shape, "LineV", { stroke: "lightgray", strokeWidth: 0.5, interval: 1 }),
            $(go.Shape, "LineV", { stroke: "gray", strokeWidth: 0.5, interval: 5 }),
            $(go.Shape, "LineV", { stroke: "gray", strokeWidth: 1.0, interval: 10 })
            );


        function finishDrop(e, grp) {      
            console.log("finishDrop")
            var ok = (grp !== null
            ? grp.addMembers(grp.diagram.selection, true)
            : e.diagram.commandHandler.addTopLevelParts(e.diagram.selection, true));
            if (!ok) e.diagram.currentTool.doCancel();        
        }

        function highlightGroup(e, grp, show) { 
            if (!grp) return;
            e.handled = true;
            if (show) {
            // cannot depend on the grp.diagram.selection in the case of external drag-and-drops;
            // instead depend on the DraggingTool.draggedParts or .copiedParts
            var tool = grp.diagram.toolManager.draggingTool;
            var map = tool.draggedParts || tool.copiedParts;  // this is a Map
            // now we can check to see if the Group will accept membership of the dragged Parts
            if (grp.canAddMembers(map.toKeySet())) {
                //grp.isHighlighted = true;
                grp.findObject("SHAPE").fill = "#FBB5B5";
                return;
            }
            }
            //grp.isHighlighted = false;
            grp.findObject("SHAPE").fill = "white";
            grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = null;
            grp.findObject("AREA_STREAM_INPUT_PORT").fill = null;
        };




      

      
      
      // install the PortShiftingTool as a "mouse move" tool
      myDiagram.toolManager.mouseMoveTools.insertAt(0, new PortShiftingTool());
      // when the document is modified, add a "*" to the title and enable the "Save" button
      myDiagram.addDiagramListener("Modified", function(e) {
          console.log("DiagramListener");
        var currentFile = document.getElementById("currentFile");
        var idx = currentFile.textContent.indexOf("*");
        if (e.diagram.isModified) {
          if (idx < 0) currentFile.textContent = currentFile.textContent + "*";
        } else {
          if (idx >= 0) currentFile.textContent = currentFile.textContent.substr(0, idx);
        }
      });
      
      palette = new go.Palette("palette");  // create a new Palette in the HTML DIV element "palette"
      // creates relinkable Links that will avoid crossing Nodes when possible and will jump over other Links in their paths
      myDiagram.linkTemplate =
        $(go.Link,
          {
            routing: go.Link.AvoidsNodes,
            curve: go.Link.JumpOver,
            corner: 0,
            relinkableFrom: true, relinkableTo: true,
            reshapable: true,
            selectionAdorned: false, // Links are not adorned when selected so that their color remains visible.
            shadowOffset: new go.Point(0, 0), shadowBlur: 5, shadowColor: "blue",
          },
          new go.Binding("isShadowed", "isSelected").ofObject(),
          new go.Binding("points", "segArray", 
            function(data,node) { 
              var arr = data.split(",");
              var list = new go.List();

              list.add(go.Point.parse(arr[0]));
              list.add(go.Point.parse(arr[1]));
              list.add(go.Point.parse(arr[2]));
              list.add(go.Point.parse(arr[3]));
              list.add(go.Point.parse(arr[4]));
              list.add(go.Point.parse(arr[5]));

              return list;
            } 
          ).makeTwoWay(
            function (points) {
              var arr = points.toArray();

              var p0, p1, p2, p3, p4, p5;
              p0 = go.Point.stringify(arr[0]);
              p1 = go.Point.stringify(arr[1]);
              p2 = go.Point.stringify(arr[2]);
              p3 = go.Point.stringify(arr[3]);
              p4 = go.Point.stringify(arr[4]);
              p5 = go.Point.stringify(arr[5]);

              var str = p0 + "," + p1 + "," + p2 + "," + p3 + "," + p4 + "," + p5;
              return str;
            }
          ),
          //new go.Binding("isShadowed", "segArray", go.Binding.toString()).makeTwoWay(),
          $(go.Shape,
            { name: "SHAPE", strokeWidth: 1, stroke: "black" }));
      // node template helpers
      var sharedToolTip =
        $("ToolTip",
          { "Border.figure": "RoundedRectangle" },
          $(go.TextBlock, { margin: 2 },
            new go.Binding("text", "", function(d) { return d.category; })));


      // common component properties definition
      {
        function splash_componentStyle() {
          return [new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
          new go.Binding("isShadowed", "isSelected").ofObject(),
          {
            selectionAdorned: false,
            shadowOffset: new go.Point(0, 0),
            shadowBlur: 15,
            shadowColor: "blue",
            resizable: true,
            resizeObjectName: "SHAPE",
            toolTip: sharedToolTip,
            visible: true,
          }];
        }
        
        // calculate port location as a node of group to keep relative location 
        // even if the group is resized.
        function calcPortLocation(data, node) {
          if(node.isSelected) return go.Point.parse(data);

          var node_loc = go.Point.parse(data); // go.Point form
          var node_x = node_loc.x;
          var node_y = node_loc.y;
          var grp = node.containingGroup; 

          var grp_loc = grp.location;
          var grp_x = grp_loc.x;
          var grp_y = grp_loc.y;
          var grp_width = grp.actualBounds.width;
          var grp_height = grp.actualBounds.height;
          //var grp_height = grp.actualBounds.height;
          //var node_y_rel = (grp_y-node_y)/(grp_height/2);

          if(node.name === "STREAM_OUTPUT_PORT"
            || node.name === "STREAM_INPUT_PORT"
            || node.name === "STREAM_DELEGATION_PORT") {
            if(grp) {
              if(grp_x - node_x > 0) {
                node_x = grp_x - grp_width/2 - 10;
              } else  {
                node_x = grp_x + grp_width/2 - 10;
              } 
            } else {
              // on the background
            }
          } else if(node.name === "EVENT_INPUT_PORT"
                  || node.name === "EVENT_OUTPUT_PORT"
                  || node.name === "EVENT_DELEGATION_INPUT_PORT"
                  || node.name === "EVENT_DELEGATION_OUTPUT_PORT") {
            if(grp) {
                node_y = grp_y - grp_height/2 - 10;
            }
          } else if (node.name === "SOURCE" || node.name === "SINK") {
            if(grp) {
              node_y = grp_y - grp_height/2 + 10;
            }
          } else {
            // on the background
          } 
          

          node_loc.x = node_x;
          node_loc.y = node_y;
          //console.log(node_loc.x+" "+node_loc.y);
          return node_loc; // return as go.Point form
        }

        function splash_portStyle() {
          return [
            splash_componentStyle(),
            new go.Binding("location", "loc", calcPortLocation).makeTwoWay(go.Point.stringify),
            {
              resizable: false,
              selectionChanged: function(p) {
              p.zOrder = (p.isSelected ? 11 : 10);
              },
            }            
          ];
        }        

        /*
        function visibleAtomic_buildUnit(node) {
          var options = document.getElementById("select_buildUnit");
          var concealAll = document.getElementById(onlyViewCheckedBuildUnit).checked;

          if(!concealAll) {
            for(i=0; i<options.length; ++i) {
              if(node.data.BuildUnit == options[i].text) {
                addLog("visibleAtomic_buildUnit(): There are the same build unit name: "+node.data.BuildUnit);
                if(options[i].value == 1) return true;    
              }
            }
          }
          return false;
        }
        */

        function splash_atomicComponentStyle() {
          return [
            splash_componentStyle(),
            {
              ungroupable: true,
              locationSpot: go.Spot.Center,
              zOrder: 5,
              
              computesBoundsAfterDrag: false,
              // when the selection is dropped into a Group, add the selected Parts into that Group;
              // if it fails, cancel the tool, rolling back any changes
              mouseDrop: finishDrop_component,
              handlesDragDropForMembers: true,  // don't need to define handlers on member Nodes and Links.
              selectionChanged: function(p) {
                p.zOrder = (p.isSelected ? 6 : 5);
              },
            }
          ];
        }
        
        function splash_factoryStyle() {
          return [
            splash_componentStyle(),
            {
              ungroupable: true,
              locationSpot: go.Spot.Center,

              zOrder: 1,
              layerName: "Background",
              
              computesBoundsAfterDrag: true,
              // when the selection is dropped into a Group, add the selected Parts into that Group;
              // if it fails, cancel the tool, rolling back any changes
              mouseDrop: finishDrop_component,
              handlesDragDropForMembers: false,  // don't need to define handlers on member Nodes and Links.
              // selectionChanged: function(p) {
              //   p.zOrder = (p.isSelected ? 2 : 1);
              // },
            }
          ];
        }
        
         function finishDrop_component(e, grp) {
             console.log("finishDrop_component");
             var collection = new go.List();
             
             grp.diagram.selection.each(function(part) {
                if(part.category === "buildUnit") {
                    myDiagram.nodes.each(function(part2) {
                        if(part2.data.buildUnit === part.key)
                            collection.add(part2);
                    })
                }
                else {
                    collection.add(part);
                }
             })
            var ok = (grp !== null
                ?  
                    // grp.addMembers(grp.diagram.selection, true) 
                    grp.addMembers(collection, true) 
                : 
                    // e.diagram.commandHandler.addTopLevelParts(e.diagram.selection, true);
                    e.diagram.commandHandler.addTopLevelParts(collection, true));
            if (!ok) e.diagram.currentTool.doCancel();
        }
        function unset_buildUnit(e, obj) {
            var node = e.diagram.findNodeForKey(obj.part.key);
            e.diagram.remove(node);
        }
        
      }

      // stream port template definition
      {
        function update_portType(node, portType) {
          //console.log("Previous name: " + node.name);
          node.name = portType;
          //console.log("Changed name: " + node.name);
        } 

        function toggleAllStreamPort(current_diagram, obj) {
          console.log("toggleAllStreamPort()");
          var cur_shp = obj.findObject("STREAM_PORT"); 

          var nextState;

          if(obj.name === "STREAM_INPUT_PORT") {
            nextState = !cur_shp.toLinkable;
          } else if(obj.name === "STREAM_OUTPUT_PORT") {
            nextState = !cur_shp.fromLinkable;
          } else if(obj.name === "STREAM_DELEGATION_PORT") {
            nextState = !cur_shp.toLinkable;
          } 
          console.log("name?:"+obj.name);
          console.log("nextState?:"+nextState);
          toggleAllStreamPort_sync(current_diagram, nextState);
        }

        function toggleAllStreamPort_sync(current_diagram, nextState) {
          current_diagram.nodes.each(function(node) {
            if (node.name === "STREAM_INPUT_PORT" 
                || node.name === "STREAM_OUTPUT_PORT"
                || node.name === "STREAM_DELEGATION_PORT") {
              var shp = node.findObject("STREAM_PORT");
              
              if(node.name === "STREAM_INPUT_PORT") {
                if(nextState === true) {                
                  shp.toLinkable = true;
                  shp.stroke = "#FF00FF";
                  shp.strokeWidth = 2;
                } else {
                  shp.toLinkable = false;
                  shp.stroke = "black";
                  shp.strokeWidth = 1;
                }
              } else if(node.name === "STREAM_OUTPUT_PORT") {
                if(nextState === true) {                
                  shp.fromLinkable = true;
                  shp.stroke = "#FF00FF";
                  shp.strokeWidth = 2;
                } else {             
                  shp.fromLinkable = false;
                  shp.stroke = "black";
                  shp.strokeWidth = 1;
                }
              } else if(node.name === "STREAM_DELEGATION_PORT") {
                if(nextState === true) { 
                  shp.toLinkable = true;
                  shp.fromLinkable = true;
                  shp.stroke = "#FF00FF";
                  shp.strokeWidth = 2;
                } else {             
                  shp.toLinkable = false;
                  shp.fromLinkable = false;
                  shp.stroke = "black";
                  shp.strokeWidth = 1;
                }              
              } else { }
              updateStates(current_diagram);
            }
          });
        }

        function activateAllStreamPort(current_diagram) {
          toggleAllStreamPort_sync(current_diagram, true);
        }

        function deactivateAllStreamPort(current_diagram) {
          toggleAllStreamPort_sync(current_diagram, false);
        }


        function alignToPort(e, obj) {
          var criterion_y = go.Point.parse(obj.part.data.loc).y;

          console.log(obj.part.key);
          console.log(obj.part.data.loc);
          console.log(obj.part.location.x);
          console.log(obj.part.location.y);
          console.log(criterion_y);

          e.diagram.selection.each(function(part) {
            if(part.name === "STREAM_UNTYPED_PORT"
              || part.name === "STREAM_INPUT_PORT"
              || part.name === "STREAM_OUTPUT_PORT"
              || part.name === "STREAM_DELEGATION_PORT") {
              part.location = new go.Point(part.location.x, criterion_y);
            }
          });
        }

        function splash_streamPortStyle() {
          return {
            name: "STREAM_PORT",
            desiredSize: new go.Size(20, 20),
            fill: "transparent",
            fromSpot: go.Spot.Right,
            fromLinkable: false,
            fromMaxLinks: Number.MAX_VALUE,
            toSpot: go.Spot.Left,
            toLinkable: false,
            toMaxLinks: 1,
            stroke: "black",
            cursor: "pointer",
          };
        }
               
        var template_streamPort = 
          $(go.Node, "Spot", splash_portStyle(),
            { 
              name: "STREAM_UNTYPED_PORT",
              zOrder : 10,
              contextMenu:     // define a context menu for each node
                $("ContextMenu",  // that has one button
                  $("ContextMenuButton",
                    $(go.TextBlock, {margin: 5, width: 150}, "Align to"),
                    { 
                      click: alignToPort 
                    })
                  // more ContextMenuButtons would go here
              )  // end Adornment
            },
          $(go.Shape, "Rectangle", 
            { width: 20, height:20, },
            new go.Binding("fill", "", function(data,node) {
              return isNaN(data.Rate) ? "white" : "gray";
            }).makeTwoWay(),
            ),
          $(go.Shape, "TriangleRight", 
            { width: 10, height: 10, },
            new go.Binding("fill", "", function(data,node) {
              return isNaN(data.Rate) ? "black" : "white";
            }).makeTwoWay(),
            ),
          $(go.Shape, "Rectangle", splash_streamPortStyle(),
            { portId: "", alignment: new go.Spot(0.5, 0.5) }),
          new go.Binding("name", "PORT_TYPE").makeTwoWay(),
          { doubleClick: function(e, obj) {
              e.diagram.startTransaction("Toggle Input");
              toggleAllStreamPort(e.diagram, obj);
              // var shp = obj.findObject("STREAM_PORT");
              
              // if(obj.name === "STREAM_INPUT_PORT") {
              //   if(shp.toLinkable === false) {                
              //     shp.toLinkable = true;
              //     shp.stroke = "#FF00FF";
              //     shp.strokeWidth = 2;
              //   } else {
              //     shp.toLinkable = false;
              //     shp.stroke = "black";
              //     shp.strokeWidth = 1;
              //   }
              // } else if(obj.name === "STREAM_OUTPUT_PORT") {
              //   if(shp.fromLinkable === false) {                
              //     shp.fromLinkable = true;
              //     shp.stroke = "#FF00FF";
              //     shp.strokeWidth = 2;
              //   } else {             
              //     shp.fromLinkable = false;
              //     shp.stroke = "black";
              //     shp.strokeWidth = 1;
              //   }
              // } else if(obj.name === "STREAM_DELEGATION_PORT") {
              //   if(shp.toLinkable === false || shp.fromLinkable === false) { 
              //     shp.toLinkable = true;
              //     shp.fromLinkable = true;
              //     shp.stroke = "#FF00FF";
              //     shp.strokeWidth = 2;
              //   } else {             
              //     shp.toLinkable = false;
              //     shp.fromLinkable = false;
              //     shp.stroke = "black";
              //     shp.strokeWidth = 1;
              //   }              
              // } else { }
              // updateStates(e.diagram);
              e.diagram.commitTransaction("Toggle Input");
            }
          }
				); 
      }     
      
      
      // event port template definition
      {
       
        function splash_eventPortStyle() {
          return {
            name: "EVENT_PORT",
            desiredSize: new go.Size(20, 20),
            fill: "transparent",
            fromSpot: go.Spot.Top,
            fromLinkable: false,
            fromMaxLinks: Number.MAX_VALUE,
            toSpot: go.Spot.Top,
            toLinkable: false,
            toMaxLinks: 1,
            stroke: "black",
            cursor: "pointer",
          };
        } 
        
        function toggleAllEventPort(e,obj) {
          var cur_shp = obj.findObject("EVENT_PORT");
          var nextState;

          if(obj.name === "EVENT_INPUT_PORT") {
            nextState = !cur_shp.toLinkable;
          } else if(obj.name === "EVENT_OUTPUT_PORT") {
            nextState = !cur_shp.fromLinkable;
          } else if(obj.name === "EVENT_DELEGATION_INPUT_PORT") {
            nextState = !cur_shp.toLinkable;
          } else if(obj.name === "EVENT_DELEGATION_OUTPUT_PORT") {
            nextState = !cur_shp.fromLinkable;
          }

          toggleAllEventPort_sync(e.diagram, nextState);
        }

        function toggleAllEventPort_sync(current_diagram, nextState) {
          current_diagram.nodes.each(function(node) {
            if (node.name === "EVENT_INPUT_PORT" 
                || node.name === "EVENT_DELEGATION_INPUT_PORT"
                || node.name === "EVENT_OUTPUT_PORT"
                || node.name === "EVENT_DELEGATION_OUTPUT_PORT") {
              var shp = node.findObject("EVENT_PORT");             
                if(node.name === "EVENT_INPUT_PORT") {
                  shp.toSpot = go.Spot.Top;
                  shp.fromSpot = go.Spot.Top;
                  if(nextState === true) {                
                    shp.toLinkable = true;
                    shp.stroke = "#FF00FF";
                    shp.strokeWidth = 2;
                  } else {
                    shp.toLinkable = false;
                    shp.stroke = "black";
                    shp.strokeWidth = 1;
                  }
                } else if (node.name === "EVENT_DELEGATION_INPUT_PORT") {
                  shp.toSpot = go.Spot.Top;
                  shp.fromSpot = go.Spot.Bottom;
                  if(nextState === true) { 
                    shp.toLinkable = true;
                    shp.fromLinkable = true;
                    shp.stroke = "#FF00FF";
                    shp.strokeWidth = 2;
                  } else {             
                    shp.toLinkable = false;
                    shp.fromLinkable = false;
                    shp.stroke = "black";
                    shp.strokeWidth = 1;
                  } 
                } else if(node.name === "EVENT_OUTPUT_PORT") {
                  shp.toSpot = go.Spot.Top;
                  shp.fromSpot = go.Spot.Top;
                  if(nextState === true) {                
                    shp.fromLinkable = true;
                    shp.stroke = "#FF00FF";
                    shp.strokeWidth = 2;
                  } else {             
                    shp.fromLinkable = false;
                    shp.stroke = "black";
                    shp.strokeWidth = 1;
                  }
                } else if (node.name === "EVENT_DELEGATION_OUTPUT_PORT"){
                  shp.toSpot = go.Spot.Bottom;
                  shp.fromSpot = go.Spot.Top;
                  if(nextState === true) { 
                    shp.toLinkable = true;
                    shp.fromLinkable = true;
                    shp.stroke = "#FF00FF";
                    shp.strokeWidth = 2;
                  } else {             
                    shp.toLinkable = false;
                    shp.fromLinkable = false;
                    shp.stroke = "black";
                    shp.strokeWidth = 1;
                  } 
                } else {}

              updateStates(current_diagram);
            }
          });
        }

        function activateAllEventPort(current_diagram) {
          toggleAllEventPort_sync(current_diagram, true);
        }

        function deactivateAllEventPort(current_diagram) {
          toggleAllEventPort_sync(current_diagram, false);
        }        

        var template_eventInputPort = 
          $(go.Node, "Spot", splash_portStyle(),
            { 
              name: "EVENT_INPUT_PORT",
              zOrder : 10
              },
            $(go.Shape, "Rectangle", 
              { fill: "white", width: 20, height:20 }),
            $(go.Shape, "ISOProcess", 
              { fill: "black", width: 16, height: 13, stroke: "white", angle: 90, alignment: new go.Spot(0.5, 0.5)},
            ),
            $(go.Shape, "Rectangle", splash_eventPortStyle(),
              { portId: "", alignment: new go.Spot(0.5, 0.5) }),
            new go.Binding("name", "PORT_TYPE").makeTwoWay(),
            { doubleClick: function(e, obj) {
                e.diagram.startTransaction("Toggle Input");
                toggleAllEventPort(obj);
                // var shp = obj.findObject("EVENT_PORT");             
                //   if(obj.name === "EVENT_INPUT_PORT") {
                //     shp.toSpot = go.Spot.Top;
                //     shp.fromSpot = go.Spot.Top;
                //     if(shp.toLinkable === false) {                
                //       shp.toLinkable = true;
                //       shp.stroke = "#FF00FF";
                //       shp.strokeWidth = 2;
                //     } else {
                //       shp.toLinkable = false;
                //       shp.stroke = "black";
                //       shp.strokeWidth = 1;
                //     }
                //   } else if (obj.name === "EVENT_DELEGATION_INPUT_PORT") {
                //     shp.toSpot = go.Spot.Top;
                //     shp.fromSpot = go.Spot.Bottom;
                //     if(shp.toLinkable === false || shp.fromLinkable === false) { 
                //       shp.toLinkable = true;
                //       shp.fromLinkable = true;
                //       shp.stroke = "#FF00FF";
                //       shp.strokeWidth = 2;
                //     } else {             
                //       shp.toLinkable = false;
                //       shp.fromLinkable = false;
                //       shp.stroke = "black";
                //       shp.strokeWidth = 1;
                //     } 
                //   } else {}

                // updateStates(myDiagram);
                e.diagram.commitTransaction("Toggle Input");
              }
            }
  				); 
      
      
        var template_eventOutputPort = 
          $(go.Node, "Spot", splash_portStyle(),
            { 
              name: "EVENT_OUTPUT_PORT",
              zOrder : 10
              },
            $(go.Shape, "Rectangle", 
              { fill: "white", width: 20, height:20 }),
            $(go.Shape, "ISOProcess", 
              { fill: "black", width: 16, height: 13, stroke: "white", angle: 270, alignment: new go.Spot(0.5, 0.5)},
            ),
            $(go.Shape, "Rectangle", splash_eventPortStyle(),
              { portId: "", alignment: new go.Spot(0.5, 0.5) }),
            new go.Binding("name", "PORT_TYPE").makeTwoWay(),
            { doubleClick: function(e, obj) {
                e.diagram.startTransaction("Toggle Input");
                var shp = obj.findObject("EVENT_PORT");             
                toggleAllEventPort(e,obj);
                //   if(obj.name === "EVENT_OUTPUT_PORT") {
                //     shp.toSpot = go.Spot.Top;
                //     shp.fromSpot = go.Spot.Top;
                //     if(shp.fromLinkable === false) {                
                //       shp.fromLinkable = true;
                //       shp.stroke = "#FF00FF";
                //       shp.strokeWidth = 2;
                //     } else {             
                //       shp.fromLinkable = false;
                //       shp.stroke = "black";
                //       shp.strokeWidth = 1;
                //     }
                //   } else if (obj.name === "EVENT_DELEGATION_OUTPUT_PORT"){
                //     shp.toSpot = go.Spot.Bottom;
                //     shp.fromSpot = go.Spot.Top;
                //     if(shp.toLinkable === false || shp.fromLinkable === false) { 
                //       shp.toLinkable = true;
                //       shp.fromLinkable = true;
                //       shp.stroke = "#FF00FF";
                //       shp.strokeWidth = 2;
                //     } else {             
                //       shp.toLinkable = false;
                //       shp.fromLinkable = false;
                //       shp.stroke = "black";
                //       shp.strokeWidth = 1;
                //     } 
                //   } else {}

                // updateStates(myDiagram);
                e.diagram.commitTransaction("Toggle Input");
              }
            }
  				); 
      }
      
      
      // mode change port template definition
      {
        function splash_modeChangePortStyle() {
          return {
            name: "MODECHANGE_PORT",
            desiredSize: new go.Size(20, 20),
            fill: "transparent",
            fromSpot: go.Spot.Top,
            fromLinkable: false,
            fromMaxLinks: Number.MAX_VALUE,
            toSpot: go.Spot.Top,
            toLinkable: false,
            toMaxLinks: 1,
            stroke: "black",
            cursor: "pointer",
          };
        } 
        
      var template_modeChangeInputPort = 
        $(go.Node, "Spot", splash_portStyle(),
          { 
            name: "MODECHANGE_INPUT_PORT",
            zOrder : 10
            },
          $(go.Shape, "Rectangle", 
            { fill: "white", width: 20, height:20 }),
          $(go.Shape, "Circle", 
            { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.5, 0.7) }),
          $(go.Shape, "Circle", 
            { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.5-0.231, 0.3) }),
          $(go.Shape, "Circle", 
            { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.5+0.231, 0.3) }),
          $(go.Shape, "Rectangle", splash_eventPortStyle(),
            { portId: "", alignment: new go.Spot(0.5, 0.5) }),
          { doubleClick: function(e, obj) {
              e.diagram.startTransaction("Toggle Input");
              var shp = obj.findObject("EVENT_PORT");             

                if(shp.toLinkable === false) {                
                  shp.toLinkable = true;
                  shp.stroke = "#FF00FF";
                  shp.strokeWidth = 2;
                } else {
                  shp.toLinkable = false;
                  shp.stroke = "black";
                  shp.strokeWidth = 1;
                }

              updateStates(e.diagram);
              e.diagram.commitTransaction("Toggle Input");
            }
          }
				); 
      
      
      var template_modeChangeOutputPort = 
        $(go.Node, "Spot", splash_portStyle(),
          { 
            name: "MODECHANGE_OUTPUT_PORT",
            zOrder : 10
            },
          $(go.Shape, "Rectangle", 
            { fill: "white", width: 20, height:20 }),
          $(go.Shape, "Circle", 
            { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.5, 0.3) }),
          $(go.Shape, "Circle", 
            { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.5-0.231, 0.7) }),
          $(go.Shape, "Circle", 
            { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.5+0.231, 0.7) }),
          $(go.Shape, "Rectangle", splash_eventPortStyle(),
          ),
          $(go.Shape, "Rectangle", splash_eventPortStyle(),
            { portId: "", alignment: new go.Spot(0.5, 0.5) }),
          { doubleClick: function(e, obj) {
              e.diagram.startTransaction("Toggle Input");
              var shp = obj.findObject("EVENT_PORT");             

                if(shp.fromLinkable === false) {                
                  shp.fromLinkable = true;
                  shp.stroke = "#FF00FF";
                  shp.strokeWidth = 2;
                } else {             
                  shp.fromLinkable = false;
                  shp.stroke = "black";
                  shp.strokeWidth = 1;
                }

              updateStates(e.diagram);
              e.diagram.commitTransaction("Toggle Input");
            }
          }
				); 
      }
      
      

      
      // processing component group template definition
      {
        function calcComponentsLocation(e) {
            var sum_x = 0;
            var sum_y = 0;
            var count = 0;
            e.diagram.selection.each(function(part) {
                count++;
                sum_x += part.location.x;
                sum_y += part.location.y;
            })
            var location = (sum_x/count) + " " + (sum_y/count);
            return location;
        }
        function calcComponentsSize(e) {
            var min_top = null;
            var min_left = null;
            var max_right = null;
            var max_bottom = null;
            e.diagram.selection.each(function(part) {
                if(!min_top)
                    min_top = part.location.y;
                else if(part.location.y < min_top) 
                    min_top = part.location.y;
                if(!min_left)
                    min_left = part.location.x;
                else if(part.location.x < min_left) 
                    min_left = part.location.x;
                if(!max_bottom)
                    max_bottom = part.location.y + part.actualBounds.height;
                else if(part.location.y + part.actualBounds.height > max_bottom) 
                    max_bottom = part.location.y + part.actualBounds.height;;
                if(!max_right)
                    max_right = part.location.x + part.actualBounds.width;
                else if(part.location.x + part.actualBounds.width > max_right) 
                    max_right = part.location.x + part.actualBounds.width;
            });
            var size = (max_right - min_left + 100) + " " + (max_bottom - min_top + 100);
            return size;
        }
        function setBuildUnit_contextMenu(e, obj) {
            var buildUnit_name;
            while(true){
                buildUnit_name = prompt("Build Unit name is","Insert Build Unit Name");  
                if(!myDiagram.model.findNodeDataForKey(buildUnit_name)) break;
                alert("Already Exists");
            }
            var buildUnit_data = {
                        category: "buildUnit",  
                        text: buildUnit_name,
                    };
            myDiagram.model.addNodeData(buildUnit_data);  
            e.diagram.selection.each(function(part) {
                if(part.name === "PROCESSING"
                    || part.name === "FUSION"
                    || part.name === "SOURCE"
                    || part.name === "SINK") {
                    // part.data.buildUnit = buildUnit_name;
                    // myDiagram_buildUnit.model.setGroupKeyForNodeData(part.data, buildUnit_name);
                    if(part.data.buildUnit)
                        return;
                    myDiagram_buildUnit_selectionPane.model.setParentKeyForNodeData(part.data, buildUnit_name);
                }
                else if(part.name === "FACTORY") {
                    var it = part.memberParts;
                    while (it.next()) {
                        if(it.value.data.buildUnit)
                            return;
                        myDiagram_buildUnit_selectionPane.model.setParentKeyForNodeData(it.value.data, buildUnit_name);
                    }
                }
            });
            var arr = myDiagram.model.nodeDataArray;
            for (var i = 0; i < arr.length; i++) {
                var data = arr[i];
                var buildUnit = data.buildUnit;
                if (buildUnit) {
                    var sdata = myDiagram.model.findNodeDataForKey(buildUnit);
                    if (sdata) {
                        // update _supers to be an Array of references to node data
                        if (!data._buildUnit) {
                            data._buildUnit = [sdata];
                        } else {
                            data._buildUnit.push(sdata);
                        }
                        // update _members to be an Array of references to node data
                        if (!sdata._members) {
                            sdata._members = [data];
                        } else {
                            sdata._members.push(data);
                        }
                    }
                }
            }
            //   var options = document.getElementById("select_buildUnit");

            //   var new_option = document.createElement("option");
            //   new_option.value = 1; // display option, default is on
            //   new_option.text = buildUnit_name;

            //   var exist = false;
            //   console.log(options);
            //   if(buildUnit_name === "Insert Build Unit Name") return;
            //   else { // add new build unit, if it doesn't exist
            //     for(i=0; i<options.length; ++i) {
            //       if(options[i].text === buildUnit_name) { // set the build unit for current selected components
            //         exist = true;
            //       }
            //     }
            //   }

            //   if(!exist) {
            //     options.add(new_option);
            //     // add buildUnit item to json format array
            //     // var json_buildUnit = {"name":buildUnit_name, "Components":[], "Color":"#ffffff"};
            //     // buildUnitArray.push(json_buildUnit);
            //   }

            //   e.diagram.selection.each(function(part) {
            //     if(part.name === "PROCESSING"
            //       || part.name === "FUSION"
            //       || part.name === "SOURCE"
            //       || part.name === "SINK"
            //       || part.name === "FACTORY") {
            //       part.data.buildUnit = buildUnit_name;
            //     }
            //   });
        }
        function setBuildUnit_contextMenu_in_selectionPane(e, obj) {
            var buildUnit_name;
            while(true){
                buildUnit_name = prompt("Build Unit name is","Insert Build Unit Name");  
                if(!myDiagram.model.findNodeDataForKey(buildUnit_name)) break;
                alert("Already Exists");
            }
            var buildUnit_data = {
                        category: "buildUnit",  
                        text: buildUnit_name,
                    };
            myDiagram.model.addNodeData(buildUnit_data);  
            e.diagram.selection.each(function(part) {
                if(part.data.buildUnit)
                        return;
                var data = myDiagram.model.findNodeDataForKey(part.key);
                myDiagram_buildUnit_selectionPane.model.setParentKeyForNodeData(data, buildUnit_name);
            });
            var arr = myDiagram.model.nodeDataArray;
            for (var i = 0; i < arr.length; i++) {
                var data = arr[i];
                var buildUnit = data.buildUnit;
                if (buildUnit) {
                    var sdata = myDiagram.model.findNodeDataForKey(buildUnit);
                    if (sdata) {
                        // update _supers to be an Array of references to node data
                        if (!data._buildUnit) {
                            data._buildUnit = [sdata];
                        } else {
                            data._buildUnit.push(sdata);
                        }
                        // update _members to be an Array of references to node data
                        if (!sdata._members) {
                            sdata._members = [data];
                        } else {
                            sdata._members.push(data);
                        }
                    }
                }
            }
        }
        function unsetBuildUnit_contextMenu_in_selectionPane(e, obj) {
            var node = e.diagram.findNodeForKey(obj.part.key);
            e.diagram.remove(node);
        }
        var current_processingComponentKey;

        function editSthread_contextMenu(e, obj) {
          // get the context menu that holds the button that was clicked
          var contextmenu = obj.part;
          // get the node data to which the Node is data bound
          var nodedata = contextmenu.data;
          current_processingComponentKey = contextmenu.key;

          var copiedModel = new go.GraphLinksModel(e.diagram.model.nodeDataArray, e.diagram.model.linkDataArray);

          var new_nodeDataArray_processingComponent = copiedModel.nodeDataArray.filter(processingComponentRelatedNode);
          var new_linkDataArray_processingComponent = copiedModel.linkDataArray.filter(processingComponentRelatedNode);

          var processingComponentModel = 
            new go.GraphLinksModel(new_nodeDataArray_processingComponent, new_linkDataArray_processingComponent);

          var new_nodeDataArray_ports = copiedModel.nodeDataArray.filter(portsRelatedNode);
          var new_linkDataArray_ports = copiedModel.linkDataArray.filter(portsRelatedNode);   
 
          var portModel = 
            new go.GraphLinksModel(new_nodeDataArray_ports, new_linkDataArray_ports);

          var component_model_json = processingComponentModel.toJson();
          var port_model_json = portModel.toJson();
                           
          //console.log(component_model_json);

          updateSthreadViewer_component(component_model_json);
          updateSthreadViewer_sthread(port_model_json);
        }

        function processingComponentRelatedNode(value) {
          var condition;
          if(value.key === current_processingComponentKey || value.group === current_processingComponentKey) {
            console.log(current_processingComponentKey +"=?"+value.key);
            console.log(current_processingComponentKey +"=?"+value.group);
            condition = true; 
          } else condition = false;
          
          return condition;
        }

        function portsRelatedNode(value) {
          var condition;
          if(value.group === current_processingComponentKey) {
            condition = true; 
          } else condition = false;
          
          return condition; 
        }

        function highlightProcessingComponent(e, grp, show) { 
          if (!grp) return;
          e.handled = true;
          if (show) {
            // cannot depend on the grp.diagram.selection in the case of external drag-and-drops;
            // instead depend on the DraggingTool.draggedParts or .copiedParts
            var tool = grp.diagram.toolManager.draggingTool;
            var map = tool.draggedParts || tool.copiedParts;  // this is a Map
            // now we can check to see if the Group will accept membership of the dragged Parts
            if (grp.canAddMembers(map.toKeySet())) {    
              return;
            }
          }
          grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = null;
          grp.findObject("AREA_STREAM_INPUT_PORT").fill = null;
          grp.findObject("AREA_EVENT_PORT").fill = null;
        };
        
        var isIncoming_toProcessingComponent = false;
        var posX_atProcessingComponent;
        var posY_atProcessingComponent;
        var portType_atProcessingComponent;

        var template_processingComponent =
        $(go.Group, "Spot", splash_atomicComponentStyle(),
          {
            name: "PROCESSING",        
            contextMenu:     // define a context menu for each node
                $("ContextMenu",  // that has one button
                  $("ContextMenuButton",
                    $(go.TextBlock, {margin: 5, width: 150}, "Set Build Unit"),
                    { 
                      click: setBuildUnit_contextMenu,
                    },
                    new go.Binding("visible", "", 
                        function(o) {
                            var data = myDiagram.model.findNodeDataForKey(o.key);
                            return data.buildUnit === "" || data.buildUnit === undefined
                        }
                    )
                  )
                ),
          
            mouseDragEnter: function(e, grp, prev) {                              
              isIncoming_toProcessingComponent = true;              
              highlightProcessingComponent(e, grp, true);               
            },
            mouseDragLeave: function(e, grp, next) { 
              highlightProcessingComponent(e, grp, false); 
              isIncoming_toProcessingComponent = false;             
            },                          

            memberValidation: function(grp, node) {
              console.log("memberValidation()");
              var selectedName = node.name;
              
              var grp_loc = new go.Point(0, 0);
              var node_loc = new go.Point(0, 0);
              
              var grp_height = grp.actualBounds.height;
              var grp_width = grp.actualBounds.width;              
              
              if (grp !== null && grp.location.isReal()) {
                grp_loc = grp.location;
                node_loc = node.location;
              }

              if(selectedName === "STREAM_UNTYPED_PORT" 
                  || selectedName === "STREAM_INPUT_PORT" 
                  || selectedName === "STREAM_OUTPUT_PORT"
                  || selectedName === "STREAM_DELEGATION_PORT") {
                if(isIncoming_toProcessingComponent) {            
                     
                  if(grp_loc.x - node_loc.x > 0) {
                    grp.findObject("AREA_STREAM_INPUT_PORT").fill = "green";
                    posX_atProcessingComponent = grp_loc.x - grp_width/2-10;
                    portType_atProcessingComponent = "STREAM_INPUT_PORT";
                  }
                  else {
                    grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = "blue";
                    posX_atProcessingComponent = grp_loc.x + grp_width/2 - 10;
                    portType_atProcessingComponent = "STREAM_OUTPUT_PORT";
                  }
                  
                  return true; 
                } else {
                  update_portType(node, portType_atProcessingComponent);
                  node.position = new go.Point(posX_atProcessingComponent, node_loc.y);
                  //addLog("add a new stream port!");
                  return true;
                }
              } else if(selectedName === "EVENT_INPUT_PORT" 
                        || selectedName === "EVENT_OUTPUT_PORT"
                        || selectedName === "EVENT_DELEGATION_INPUT_PORT"
                        || selectedName === "EVENT_DELEGATION_OUTPUT_PORT") {
                if(isIncoming_toProcessingComponent) {
                  grp.findObject("AREA_EVENT_PORT").fill = "yellow";
                  posY_atProcessingComponent = grp_loc.y - grp_height/2-10;
                  return true; 
                } else {
                  node.position = new go.Point(node_loc.x, posY_atProcessingComponent);
                  if(selectedName === "EVENT_DELEGATION_INPUT_PORT") update_portType(node, "EVENT_INPUT_PORT");
                  if(selectedName === "EVENT_DELEGATION_OUTPUT_PORT") update_portType(node, "EVENT_OUTPUT_PORT");
                  //addLog("add new event port!");
                  return true;
                }
              } else { 
                return false; 
              }
            },
          },
          $(go.Shape, "Rectangle",
            { 
              name: "SHAPE" ,
              fill: "white", stroke: "black", strokeWidth: 1.5,
             	height: 100, width: 100,

            },
            new go.Binding("width", "WIDTH").makeTwoWay(),
            new go.Binding("height", "HEIGHT").makeTwoWay(), 
          ),   
          $(go.TextBlock,
            {
              editable: true,
              stretch: go.GraphObject.Horizontal,
              alignment: go.Spot.BottomLeft,
              alignmentFocus: new go.Spot(0,0,0,0),
              textAlign: "center",
              margin: 2,
              overflow: go.TextBlock.OverflowEllipsis,
              maxLines: 5,
              textValidation: function okName(textblock, oldstr, newstr) {
                                return oldstr === newstr || myDiagram.model.findNodeDataForKey(newstr) === null;
                              }
            },
            new go.Binding("text", "key").makeTwoWay(),
          ),
          
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_INPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 30,
              opacity: 0.5,
              alignment: go.Spot.Left,
              alignmentFocus: new go.Spot(0,0.5,0,0),
              }                        
          ),  
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_OUTPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 30,
              opacity: 0.5,
              alignment: go.Spot.Right,
              alignmentFocus: new go.Spot(1,0.5,0,0),              
              }            
          ),  
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_EVENT_PORT",
              stretch: go.GraphObject.Horizontal,
              fill: null, stroke: null, strokeWidth: 0,
              height: 30,
              opacity: 0.5,
              alignment: go.Spot.TopLeft,
              alignmentFocus: new go.Spot(0,0,0,0),              
            },             
          ),
        ); 
      }
      
     
      // source component group template definition
      {
      
        function highlightSourceComponent(e, grp, show) { 
          if (!grp) return;
          e.handled = true;
          if (show) {
            // cannot depend on the grp.diagram.selection in the case of external drag-and-drops;
            // instead depend on the DraggingTool.draggedParts or .copiedParts
            var tool = grp.diagram.toolManager.draggingTool;
            var map = tool.draggedParts || tool.copiedParts;  // this is a Map
            // now we can check to see if the Group will accept membership of the dragged Parts
            if (grp.canAddMembers(map.toKeySet())) {    
              return;
            }
          }
          grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = null;
        };
      
        var isIncoming_toSourceComponent = false;
        var posX_atSourceComponent;
        var posY_atSourceComponent
      
        var template_sourceComponent = 
          $(go.Group, "Spot", splash_atomicComponentStyle(),
            { 
              name: "SOURCE",
              resizable: false,
            
              mouseDragEnter: function(e, grp, prev) {                                    
                isIncoming_toSourceComponent = true;              
                highlightSourceComponent(e, grp, true);                 
              },
              mouseDragLeave: function(e, grp, next) { 
                highlightSourceComponent(e, grp, false); 
                isIncoming_toSourceComponent = false;     
              },                          

              memberAdded: function(grp, node) {
                var selectedName = node.name;
                grp.data.haveOutputPort = true;
              },
              memberRemoved: function(grp, node) {
                grp.data.haveOutputPort = false;
              },             
              
              
              memberValidation: function(grp, node) {
                console.log("memberValidation()");
                
                var selectedName = node.name;
                
                var grp_loc = new go.Point(0, 0);
                var node_loc = new go.Point(0, 0);
                
                var grp_height = grp.actualBounds.height;
                var grp_width = grp.actualBounds.width;          
                
                if (grp !== null && grp.location.isReal()) {
                   grp_loc = grp.location;
                   node_loc = node.location;
                }

                if(grp.data.haveOutputPort) return false;

                if(selectedName === "STREAM_UNTYPED_PORT" 
                    || selectedName === "STREAM_INPUT_PORT" 
                    || selectedName === "STREAM_OUTPUT_PORT"
                    || selectedName === "STREAM_DELEGATION_PORT") {
                  if(isIncoming_toSourceComponent) {
                    grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = "blue";
                    posX_atSourceComponent = grp_loc.x + grp_width/2 - 10;
                    posY_atSourceComponent = grp_loc.y - grp_height/2 + 10;                    
                    return true; 
                  } else {
                    update_portType(node, "STREAM_OUTPUT_PORT");
                    node.position = new go.Point(posX_atSourceComponent, posY_atSourceComponent);
                    //addLog("add new stream port!");

                    return true;
                  }
                } else { 
                return false; 
              }
            },
          },
            
          $(go.Shape, "Rectangle",
            { 
              name: "SHAPE",
              fill: "white", width: 80, height: 40, stroke: "black", strokeWidth: 1.5,
              alignmentFocus: new go.Spot(0,0,0,0),
            },
          ), 
          
          $(go.TextBlock,
            {
              stretch: go.GraphObject.Horizontal,
              alignment: go.Spot.BottomLeft,
              alignmentFocus: new go.Spot(0,0,0,0),
              textAlign: "center",
              margin: 2,
              overflow: go.TextBlock.OverflowEllipsis,
              maxLines: 5,              
            },
            new go.Binding("text", "key").makeTwoWay(),
          ),
          
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_OUTPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 30,
              opacity: 0.5,
              alignment: go.Spot.Right,
              alignmentFocus: new go.Spot(1,0.5,0,0),              
            },          
          ), 
        );          
      }
      
      // sink component group template definition
      {
      
        function highlightSinkComponent(e, grp, show) { 
          if (!grp) return;
          e.handled = true;
          if (show) {
            // cannot depend on the grp.diagram.selection in the case of external drag-and-drops;
            // instead depend on the DraggingTool.draggedParts or .copiedParts
            var tool = grp.diagram.toolManager.draggingTool;
            var map = tool.draggedParts || tool.copiedParts;  // this is a Map
            // now we can check to see if the Group will accept membership of the dragged Parts
            if (grp.canAddMembers(map.toKeySet())) {    
              return;
            }
          }
          grp.findObject("AREA_STREAM_INPUT_PORT").fill = null;
        };
      
        var isIncoming_toSinkComponent = false;
        var posX_atSinkComponent;
        var posY_atSinkComponent
      
        var template_sinkComponent = 
          $(go.Group, "Spot", splash_atomicComponentStyle(),
            { 
              name: "SINK",
              resizable: false,
            
              mouseDragEnter: function(e, grp, prev) {      
                console.log("mouseDragEnter()");
                              
                isIncoming_toSinkComponent = true;              
                highlightSinkComponent(e, grp, true); 
                
              },
              mouseDragLeave: function(e, grp, next) { 
                console.log("mouseDragLeave()");
                highlightSinkComponent(e, grp, false); 
                isIncoming_toSinkComponent = false;     
                console.log("mouseDragLeave() end");
              },                          

              memberAdded: function(grp, node) {
                var selectedName = node.name;
                grp.data.haveInputPort = true;
              },
              memberRemoved: function(grp, node) {
                grp.data.haveInputPort = false;
              },             
              
              
              memberValidation: function(grp, node) {
                console.log("memberValidation()");

                
                var selectedName = node.name;
                
                var grp_loc = new go.Point(0, 0);
                var node_loc = new go.Point(0, 0);
                
                var grp_height = grp.actualBounds.height;
                var grp_width = grp.actualBounds.width;              
                
                if (grp !== null && grp.location.isReal()) {
                  grp_loc = grp.location;
                  node_loc = node.location;
                }

                if(grp.data.haveInputPort) return false;

                if(selectedName === "STREAM_UNTYPED_PORT" 
                    || selectedName === "STREAM_INPUT_PORT" 
                    || selectedName === "STREAM_OUTPUT_PORT"
                    || selectedName === "STREAM_DELEGATION_PORT") {
                  if(isIncoming_toSinkComponent) {
                    grp.findObject("AREA_STREAM_INPUT_PORT").fill = "green";
                    posX_atSinkComponent = grp_loc.x - grp_width/2 - 10;
                    posY_atSinkComponent = grp_loc.y - grp_height/2 + 10;           
                    return true; 
                  } else {
                    update_portType(node, "STREAM_INPUT_PORT");
                    node.position = new go.Point(posX_atSinkComponent, posY_atSinkComponent);
                    //addLog("add new stream port!");

                    return true;
                  }
                } else { 
                return false; 
              }
            },
          },
            
          $(go.Shape, "Rectangle",
            { 
              name: "SHAPE",
              fill: "white", width: 80, height: 40, stroke: "black", strokeWidth: 1.5
            },
          ), 
    
          $(go.TextBlock,
            {
              stretch: go.GraphObject.Horizontal,
              alignment: go.Spot.BottomLeft,
              alignmentFocus: new go.Spot(0,0,0,0),
              textAlign: "center",
              margin: 2,
              overflow: go.TextBlock.OverflowEllipsis,
              maxLines: 5,
              
            },
            new go.Binding("text", "key").makeTwoWay(),   
          ),
    
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_INPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 30,
              opacity: 0.5,
              alignment: go.Spot.Left,
              alignmentFocus: new go.Spot(0,0.5,0,0),              
            }            
          ), 
        );          
      }
      
      // fusion component group template definition
      {      
        function UpdatePropertyWindow_fusionOperator(node) {
          if(node.name == "FUSION") document.getElementById("selected_fusionOperator").value = node.key;
          else if(node.name == "STREAM_INPUT_PORT") document.getElementById("selected_inputPort_fusionOperator").value = node.key;
          //infoFusionOperator();
        }

        function highlightFusionOperator(e, grp, show) { 
          if (!grp) return;
          e.handled = true;
          if (show) {
            // cannot depend on the grp.diagram.selection in the case of external drag-and-drops;
            // instead depend on the DraggingTool.draggedParts or .copiedParts
            var tool = grp.diagram.toolManager.draggingTool;
            var map = tool.draggedParts || tool.copiedParts;  // this is a Map
            // now we can check to see if the Group will accept membership of the dragged Parts
            if (grp.canAddMembers(map.toKeySet())) {    
              return;
            }
          }
          grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = null;
          grp.findObject("AREA_STREAM_INPUT_PORT").fill = null;
        };

       
        var isIncoming_toFusionOperator = false;
        var posX_atFusionOperator;
        var posY_atFusionOperator;
        var portType_atFusionOperator;

        
        var template_fusionOperator =
        $(go.Group, "Spot", splash_atomicComponentStyle(),
          {
            name: "FUSION",
            
            mouseDragEnter: function(e, grp, prev) {      
              //console.log("mouseDragEnter()");
              isIncoming_toFusionOperator = true;              
              highlightFusionOperator(e, grp, true); 
            },
            mouseDragLeave: function(e, grp, next) { 
              //console.log("mouseDragLeave()");
              highlightFusionOperator(e, grp, false); 
              isIncoming_toFusionOperator = false;              
            },                          
            
            memberAdded: function(grp, node) {
              var selectedName = node.name;
              if(node.name === "STREAM_OUTPUT_PORT") grp.data.haveOutputPort = true;
            },
            memberRemoved: function(grp, node) {
              // TODO: modify, node has an after-removed property
              if(node.name === "STREAM_OUTPUT_PORT") grp.data.haveOutputPort = false;
            }, 
            
            
            memberValidation: function(grp, node) {
              console.log("memberValidation()");
              var selectedName = node.name;
              var grp_loc = new go.Point(0, 0);
              var node_loc = new go.Point(0, 0);
              var grp_height = grp.actualBounds.height;
              var grp_width = grp.actualBounds.width;              
              
              if (grp !== null && grp.location.isReal()) {
                grp_loc = grp.location;
                node_loc = node.location;
              }
             
              if(selectedName === "STREAM_UNTYPED_PORT" 
                || selectedName === "STREAM_INPUT_PORT" 
                || selectedName === "STREAM_OUTPUT_PORT"
                || selectedName === "STREAM_DELEGATION_PORT") {
                if(isIncoming_toFusionOperator) {            
                     
                  if(grp_loc.x - node_loc.x > 0) {
                    grp.findObject("AREA_STREAM_INPUT_PORT").fill = "green";
                    posX_atFusionOperator = grp_loc.x - grp_width/2 - 10;
                    portType_atFusionOperator = "STREAM_INPUT_PORT";
                  }
                  else {
                    if(grp.data.haveOutputPort) return false;
                    
                    grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = "blue";
                    posX_atFusionOperator = grp_loc.x + grp_width/2 - 10;
                    posY_atFusionOperator = grp.actualBounds.y + grp.findObject("SHAPE").width/2 - 10;  
                    portType_atFusionOperator = "STREAM_OUTPUT_PORT";
                    
                  }
                  
                  return true; 
                } else {
                  update_portType(node, portType_atFusionOperator);
                  console.log(grp_loc);
                  console.log(grp_height + ", " + grp_width);
                  console.log(node_loc);
                  
                  if(node.name === "STREAM_OUTPUT_PORT") {                    
                    node.position = new go.Point(posX_atFusionOperator, posY_atFusionOperator);
                  } else {
                    node.position = new go.Point(posX_atFusionOperator, node_loc.y);
                  }
                  return true;
                }
              } else { return false; }
            },


          },
          $(go.Shape, "Trapezoid",
            { 
              name: "SHAPE" , 
              height: 40, width: 100,
              fill: "white", stroke: "black", strokeWidth: 1.5, angle: 90 
            },

            new go.Binding("height", "WIDTH").makeTwoWay(),  
            new go.Binding("width", "HEIGHT").makeTwoWay(),              
          ),
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_INPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 20,
              opacity: 0.5,
              alignment: go.Spot.Left,
              alignmentFocus: new go.Spot(0,0.5,0,0),
              }            
          ),  

          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_OUTPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 20,
              opacity: 0.5,
              alignment: go.Spot.Right,
              alignmentFocus: new go.Spot(1,0.5,0,0),              
            }            
          ),

          $(go.TextBlock,
            {
              stretch: go.GraphObject.Horizontal,
              alignment: go.Spot.BottomLeft,
              alignmentFocus: new go.Spot(0,0,0,0),
              textAlign: "center",
              margin: 2,
              overflow: go.TextBlock.OverflowEllipsis,
              maxLines: 5,
              
            },
            new go.Binding("text", "key").makeTwoWay(),
          ),

          $(go.Shape, "Rectangle",
            new go.Binding("height", "actualBounds", function(b) {return b.height*0.6;}).ofObject("SHAPE"),
            { 
              name: "AREA_STREAM_OUTPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 30,
              opacity: 0.5,
              alignment: go.Spot.Right,
              alignmentFocus: new go.Spot(1,0.5,0,0),              
              }
          ),            
        ); 
      }
            
      // factory group template definition
      {
        var current_factoryKey;

        function saveFactory(e, obj) {
          // get the context menu that holds the button that was clicked
          var contextmenu = obj.part;
          // get the node data to which the Node is data bound
          var nodedata = contextmenu.data;
          current_factoryKey = contextmenu.key;

          var copiedModel = new go.GraphLinksModel(e.diagram.model.nodeDataArray, myDiagram.model.linkDataArray);


          var new_nodeDataArray = copiedModel.nodeDataArray.filter(factoryRelatedNode);
          var new_linkDataArray = copiedModel.linkDataArray.filter(factoryRelatedNode);

          var factoryModel = new go.GraphLinksModel(new_nodeDataArray, new_linkDataArray);
 
          var blob = new Blob([factoryModel.toJson()], {type: "application/json"});
          saveAs(blob, nodedata.NAME+".json");
                           
        }

        function factoryRelatedNode(value) {
          var condition;
          if(value.key === current_factoryKey || value.group === current_factoryKey) {
            console.log(current_factoryKey +"=?"+value.key);
            console.log(current_factoryKey +"=?"+value.group);
            condition = true; 
          } else condition = false;
          
          return condition;
        }

        function highlightFactory(e, grp, show) { 
          if (!grp) return;
          e.handled = true;
          if (show) {
            // cannot depend on the grp.diagram.selection in the case of external drag-and-drops;
            // instead depend on the DraggingTool.draggedParts or .copiedParts
            var tool = grp.diagram.toolManager.draggingTool;
            var map = tool.draggedParts || tool.copiedParts;  // this is a Map
            // now we can check to see if the Group will accept membership of the dragged Parts
            if (grp.canAddMembers(map.toKeySet())) {
              return;
            }
          }
          grp.findObject("SHAPE").fill = "white";
          grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = null;
          grp.findObject("AREA_STREAM_INPUT_PORT").fill = null;
          grp.findObject("AREA_EVENT_PORT").fill = null;
        };
      

        
        var isIncoming_toFactory = false;
        var posX_atFactory;
        var posY_atFactory;
        var portType_atFactory;
        
        var template_buildUnit =
        $(go.Group, "Spot", splash_factoryStyle(),
          {
            selectionObjectName: "BUILDUNIT",
            locationObjectName: "BUILDUNIT",
            resizeObjectName: "BUILDUNIT",
            
            mouseDragEnter: function(e, grp, prev) {      
              console.log("mouseDragEnter()");
            },
            mouseDragLeave: function(e, grp, next) { 
              console.log("mouseDragLeave()");           
            },                          

            memberAdded: function(grp, node) {
                console.log("memberAdded()");
            },

            memberValidation: function(grp, node) {
              console.log("memberValidation")
              return true;
            },

            contextMenu:     // define a context menu for each node
              $("ContextMenu",  // that has one button
                $("ContextMenuButton",
                  $(go.TextBlock, {margin: 5, width: 150}, "Unset BuildUnit"),
                  { click: function(e, obj) {
                      return;
                  } })
                // more ContextMenuButtons would go here
            )  // end Adornment
          },
          new go.Binding("location", "loc", go.Point.parse),
          $(go.Shape, "RoundedRectangle",
            { 
              name: "BUILDUNIT" ,
              fill: "rgba(255, 255, 255, 0.0)", stroke: "black", parameter1: 10, strokeWidth: 3, strokeDashArray: [4, 2],
            }, 
            new go.Binding("desiredSize", "size", go.Size.parse).makeTwoWay(go.Size.stringify),
          ),  
          $(go.TextBlock,
            {
              stretch: go.GraphObject.Horizontal,
              alignment: go.Spot.BottomLeft,
              alignmentFocus: new go.Spot(0,0,0,0),
              textAlign: "center",
              margin: 2,
              overflow: go.TextBlock.OverflowEllipsis,
              maxLines: 5,
              
            },
            new go.Binding("text", "key").makeTwoWay(), 
          ),
        ); 
        var template_factory =
        $(go.Group, "Spot", splash_factoryStyle(),
          {
            name: "FACTORY",
            mouseDragEnter: function(e, grp, prev) {      
              console.log("mouseDragEnter()");
              isIncoming_toFactory = true;              
              highlightFactory(e, grp, true); 
            },
            mouseDragLeave: function(e, grp, next) { 
              console.log("mouseDragLeave()");
              highlightFactory(e, grp, false); 
              isIncoming_toFactory = false;              
            },                          

            memberAdded: function(grp, node) {
                console.log("memberAdded");
            	if(node.name === "FACTORY") {
            		grp.zOrder = node.zOrder-1;
                console.log("yes factory");
            	}
            },

            memberValidation: function(grp, node) {
              console.log("memberValidation()");
              var selectedName = node.name;
              var grp_loc = new go.Point(0, 0);
              var node_loc = new go.Point(0, 0);
              
              var grp_height = grp.actualBounds.height;
              var grp_width = grp.actualBounds.width;              
              
              if (grp !== null && grp.location.isReal()) {
                grp_loc = grp.location;
                node_loc = node.location;
              }
              if(selectedName === "STREAM_UNTYPED_PORT" 
              || selectedName === "STREAM_INPUT_PORT" 
              || selectedName === "STREAM_OUTPUT_PORT"
              || selectedName === "STREAM_DELEGATION_PORT") {
                if(isIncoming_toFactory) {   
                     
                  if(grp_loc.x - node_loc.x > 0) {
                    grp.findObject("AREA_STREAM_INPUT_PORT").fill = "green";
                    posX_atFactory = grp_loc.x - grp_width/2 - 10;
                    portType_atFactory = "STREAM_DELEGATION_PORT";
                    return true;
                  }
                  else {
                    grp.findObject("AREA_STREAM_OUTPUT_PORT").fill = "blue";
                    posX_atFactory = grp_loc.x + grp_width/2 - 10;
                    portType_atFactory = "STREAM_DELEGATION_PORT";
                  }                  
                  return true; 
                } else {
                  update_portType(node, portType_atFactory);
                  node.position = new go.Point(posX_atFactory, node_loc.y);
                  return true;
                }
              } else if(selectedName === "EVENT_INPUT_PORT" 
                        || selectedName === "EVENT_OUTPUT_PORT"
                        || selectedName === "EVENT_DELEGATION_INPUT_PORT"
                        || selectedName === "EVENT_DELEGATION_OUTPUT_PORT") {
                if(isIncoming_toFactory) {
                    grp.findObject("AREA_EVENT_PORT").fill = "yellow";
                    posY_atFactory = grp_loc.y - grp_height/2-10;
                  return true; 
                } else {
                  node.position = new go.Point(node_loc.x, posY_atFactory);
                  if(selectedName === "EVENT_INPUT_PORT") update_portType(node, "EVENT_DELEGATION_INPUT_PORT");
                  if(selectedName === "EVENT_OUTPUT_PORT") update_portType(node, "EVENT_DELEGATION_OUTPUT_PORT");
                  //addLog("add new event port!");
                  return true;
                }
              } else {
                if(isIncoming_toFactory) grp.findObject("SHAPE").fill = "#FBB5B5";
                return true; 

              }
            },

            contextMenu:     // define a context menu for each node
              $("ContextMenu",  
                $("ContextMenuButton",
                  $(go.TextBlock, {margin: 5, width: 150}, "Save factory as json"),
                  { click: saveFactory }),
                $("ContextMenuButton",
                  $(go.TextBlock, {margin: 5, width: 150}, "Set Build Unit"),
                    { 
                      click: setBuildUnit_contextMenu 
                    },
                    new go.Binding("visible", "", 
                        function(o) {
                            var list = []
                            myDiagram.nodes.each(function(node) {
                                if (node.data.group === o.key) {
                                    list.push(node);
                                }
                            });
                            console.log(list);
                            var flag = false;
                            list.forEach(function(node) {
                                console.log(node);
                                if(node.data.buildUnit === "" || node.data.buildUnit === undefined) flag = true;
                            })
                            return flag;
                        }
                    )
                )
                // more ContextMenuButtons would go here
            )  // end Adornment
          },
          $(go.Shape, "RoundedRectangle",
            { 
              name: "SHAPE" ,
              fill: "white", stroke: "black", parameter1: 10, strokeWidth: 3, 
              width: 450, height: 250,
            }, 
            new go.Binding("width", "WIDTH").makeTwoWay(),
            new go.Binding("height", "HEIGHT").makeTwoWay(),     

          ),  

          $(go.TextBlock,
            {
              stretch: go.GraphObject.Horizontal,
              alignment: go.Spot.BottomLeft,
              alignmentFocus: new go.Spot(0,0,0,0),
              textAlign: "center",
              margin: 2,
              overflow: go.TextBlock.OverflowEllipsis,
              maxLines: 5,
              
            },
            new go.Binding("text", "key").makeTwoWay(), 
          ),

          /*
          $(go.TextBlock,
            {
              stretch: go.GraphObject.Horizontal,
              alignment: go.Spot.BottomLeft,
              alignmentFocus: new go.Spot(0,0,0,0),
              textAlign: "center",
              margin: 2,
              overflow: go.TextBlock.OverflowEllipsis,
              maxLines: 1,
              
            },
            new go.Binding("text", "MODE").makeTwoWay(),
          ),
          */
          
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_INPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 30,
              opacity: 0.5,
              alignment: go.Spot.Left,
              alignmentFocus: new go.Spot(0,0.5,0,0),
              }            
          ),  
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_STREAM_OUTPUT_PORT",
              stretch: go.GraphObject.Vertical,
              fill: null, stroke: null, strokeWidth: 0,
              width: 30,
              opacity: 0.5,
              alignment: go.Spot.Right,
              alignmentFocus: new go.Spot(1,0.5,0,0),              
              }            
          ),
          $(go.Shape, "Rectangle",
            { 
              name: "AREA_EVENT_PORT",
              stretch: go.GraphObject.Horizontal,
              fill: null, stroke: null, strokeWidth: 0,
              height: 30,
              opacity: 0.5,
              alignment: go.Spot.TopLeft,
              alignmentFocus: new go.Spot(0,0,0,0),              
            }  
            
          ),
        ); 
      }  
          
      // add the templates created above to myDiagram and palette
      myDiagram.nodeTemplateMap.add("streamPort", template_streamPort);
      myDiagram.nodeTemplateMap.add("eventInputPort", template_eventInputPort);
      myDiagram.nodeTemplateMap.add("eventOutputPort", template_eventOutputPort);
      myDiagram.nodeTemplateMap.add("modeChangeInputPort", template_modeChangeInputPort);
      myDiagram.nodeTemplateMap.add("modeChangeOutputPort", template_modeChangeOutputPort); 
      myDiagram.nodeTemplateMap.add("buildUnit",
        $(go.Node, "Auto",
          { 
              locationObjectName: "BODY", 
          zOrder: 1, 
          contextMenu:     // define a context menu for each node
                $("ContextMenu",  // that has one button
                  $("ContextMenuButton",
                    $(go.TextBlock, {margin: 5, width: 150}, "Unset BuildUnit"),
                    { 
                      click: unset_buildUnit
                    })
              ) 
          },
          $(go.Shape, "RoundedRectangle",
          
            {
              fill: "rgba(255, 255, 255, 0.0)", strokeWidth: 1.5, parameter1: 20, strokeDashArray: [4, 2], 
              spot1: go.Spot.TopLeft, spot2: go.Spot.BottomRight, minSize: new go.Size(30, 30)
            }),
          $(go.Panel, "Vertical",
            { margin: 10 },
            $(go.TextBlock,
              { font: "bold 10pt sans-serif", margin: new go.Margin(0, 0, 5, 0) },
              new go.Binding("text", "key").makeTwoWay()),
            $(go.Shape,
              { name: "BODY", opacity: 0 })
          )
        ));
      myDiagram.groupTemplateMap.add("sourceComponent", template_sourceComponent);   
      myDiagram.groupTemplateMap.add("sinkComponent", template_sinkComponent);            
      myDiagram.groupTemplateMap.add("fusionOperator", template_fusionOperator);     
      myDiagram.groupTemplateMap.add("processingComponent", template_processingComponent);
      myDiagram.groupTemplateMap.add("factory", template_factory);
    //   myDiagram.groupTemplateMap.add("buildUnit", template_buildUnit)
      myDiagram_buildUnit = $(go.Diagram, "buildUnitViewer",  // create a Diagram for the DIV HTML element
        {            
            layout: $(CustomLayout),
            "undoManager.isEnabled": false,            
            "draggingTool.isEnabled": false,  
            "clickSelectingTool.isEnabled": true, 
            hasHorizontalScrollbar: false,
            "ChangedSelection": function(e) {
                    if (myChangingSelection) return;
                    myChangingSelection = true;
                    var diagnodes = new go.Set();
                    myDiagram_buildUnit.selection.each(function(n) {
                    diagnodes.add(myDiagram_buildUnit_selectionPane.findNodeForData(n.data));
                    });
                    myDiagram_buildUnit_selectionPane.clearSelection();
                    myDiagram_buildUnit_selectionPane.selectCollection(diagnodes);
                    myChangingSelection = false;
                },  // defined below, to enable/disable commands
          });
      
      myDiagram_buildUnit.nodeTemplateMap = myDiagram.nodeTemplateMap;
      myDiagram_buildUnit.groupTemplateMap = myDiagram.groupTemplateMap;
      myDiagram_buildUnit.linkTemplate = myDiagram.linkTemplate;
      myDiagram_buildUnit_selectionPaneTitle = $(go.Diagram, "selectionPaneTitle", {
            initialContentAlignment: go.Spot.Top,
            contentAlignment: go.Spot.TopLeft,
            allowMove: false,
            allowCopy: false,
            allowDelete: false,
            allowHorizontalScroll: false,
            allowVerticalScroll: false,
            allowSelect: false,
      });
      myDiagram_buildUnit_selectionPaneTitle.add($(go.Part, { location: new go.Point(0, 0) }, $(go.TextBlock, "Selection", { font: "bold 28pt sans-serif", stroke: "black" })));

      myDiagram_buildUnit_selectionPane = $(go.Diagram, "selectionPane",
        {
            initialContentAlignment: go.Spot.Top,
            allowSelect: true,
            allowMove: false,
            allowCopy: false,
            allowDelete: false,
            allowHorizontalScroll: false, 
            scrollsPageOnFocus: true,
            contentAlignment: go.Spot.TopLeft,
            "panningTool.isEnabled": false,
            layout:
                $(go.TreeLayout,
                {
                    alignment: go.TreeLayout.AlignmentStart,
                    angle: 0,
                    compaction: go.TreeLayout.CompactionNone,
                    layerSpacing: 16,
                    layerSpacingParentOverlap: 1,
                    nodeIndent: 2,
                    nodeIndentPastParent: 0.88,
                    nodeSpacing: 0,
                    setsPortSpot: false,
                    setsChildPortSpot: false
                }),
            "ViewportBoundsChanged": function(e) {
                //let allowScroll = !e.diagram.viewportBounds.containsRect(e.diagram.documentBounds);
                // myDiagram_buildUnit_selectionPane.allowVerticalScroll = allowScroll;

            },
            "ChangedSelection": function(e) {
                if (myChangingSelection) return;
                myChangingSelection = true;
                var diagnodes = new go.Set();
                myDiagram_buildUnit_selectionPane.selection.each(function(n) {
                    diagnodes.add(myDiagram_buildUnit.findNodeForData(n.data));
                });
                myDiagram_buildUnit.clearSelection();
                myDiagram_buildUnit.selectCollection(diagnodes);
                myChangingSelection = false;
            }
            });
      myDiagram_buildUnit_selectionPane.add($(go.Part, { location: new go.Point(0, -70) }, $(go.TextBlock, "Selection", { font: "bold 28pt sans-serif", stroke: "black" })));
      
      //myDiagram_buildUnit.isEnabled = false;
      //myDiagram_buildUnit.model = myDiagram.model;
      myDiagram_buildUnit_selectionPane.nodeTemplate =
        $(go.Node,
          // no Adornment: instead change panel background color by binding to Node.isSelected
          { 
            selectionAdorned: false, 
            contextMenu:     // define a context menu for each node
                $("ContextMenu",  // that has one button
                  $("ContextMenuButton",
                    $(go.TextBlock, {margin: 5, width: 150}, "Set Build Unit"),
                    { 
                      click: setBuildUnit_contextMenu_in_selectionPane,
                    },
                    new go.Binding("visible", "", 
                        function(o) {
                            var data = myDiagram.model.findNodeDataForKey(o.key);
                            return data.category !== "buildUnit" && ( data.buildUnit === "" || data.buildUnit === undefined)
                        }
                    )
                  ),
                  $("ContextMenuButton",
                    $(go.TextBlock, {margin: 5, width: 150}, "Unset Build Unit"),
                    { 
                      click: unsetBuildUnit_contextMenu_in_selectionPane,
                    },
                    new go.Binding("visible", "", 
                        function(o) {
                            var data = myDiagram.model.findNodeDataForKey(o.key);
                            return data.category === "buildUnit"
                        }
                    )
                  )
                ),
          },
          $("TreeExpanderButton",
            {
              width: 14,
              "ButtonBorder.fill": "whitesmoke",
              "ButtonBorder.stroke": null,
              "_buttonFillOver": "rgba(0,128,255,0.25)",
              "_buttonStrokeOver": null
            }),
          $(go.Panel, "Horizontal",
            { position: new go.Point(16, 0) },
            new go.Binding("background", "isSelected", function (s) { return (s ? "lightblue" : "white"); }).ofObject(),
            $(go.TextBlock,
              new go.Binding("text", "key"))
          )  // end Horizontal Panel
        );  // end Node
    myDiagram_buildUnit_selectionPane.linkTemplate = $(go.Link);
    myDiagram_buildUnit_selectionPane.model = $(go.TreeModel, { nodeParentKeyProperty: "buildUnit" });
    
    
    myDiagram_buildUnit_selectionPane.addModelChangedListener(function(e) {
        if (e.model.skipsUndoManager) return;
        if (myChangingModel) return;
        myChangingModel = true;
        // don't need to start/commit a transaction because the UndoManager is shared with myDiagram
        if (e.modelChange === "nodeGroupKey" || e.modelChange === "nodeParentKey") {
          // handle structural change: tree parent/children
          var node = myDiagram.findNodeForData(e.object);
          if (node !== null) node.updateRelationshipsFromData();
        } else if (e.change === go.ChangedEvent.Property) {
          // propagate simple data property changes back to the main Diagram
          var node = myDiagram.findNodeForData(e.object);
          if (node !== null) node.updateTargetBindings();
        } else if (e.change === go.ChangedEvent.Insert && e.propertyName === "nodeDataArray") {
          // pretend the new data isn't already in the nodeDataArray for the main Diagram model
          myDiagram.model.nodeDataArray.splice(e.newParam, 1);
          // now add to the myDiagram model using the normal mechanisms
          myDiagram.model.addNodeData(e.newValue);
        } else if (e.change === go.ChangedEvent.Remove && e.propertyName === "nodeDataArray") {
          // remove the corresponding node from the main Diagram
          var node = myDiagram.findNodeForData(e.oldValue);
          if (node !== null) myDiagram.remove(node);
        }
        myChangingModel = false;
      });
      myDiagram_buildUnit_selectionPaneTitle.requestUpdate();
      myDiagram_buildUnit_selectionPane.requestUpdate();
      myDiagram.addModelChangedListener(function(e) {
            // if (e.isTransactionFinished) enableAll();
            if (e.model.skipsUndoManager) return;
            if (myChangingModel) return;
            myChangingModel = true;
            // don't need to start/commit a transaction because the UndoManager is shared with myDiagram_buildUnit_selectionPane
            if (e.modelChange === "nodeGroupKey" || e.modelChange === "nodeParentKey") {
                // handle structural change: group memberships
                var treenode = myDiagram_buildUnit_selectionPane.findNodeForData(e.object);
                if (treenode !== null) treenode.updateRelationshipsFromData();
            } 
            else if (e.change === go.ChangedEvent.Property) {
                var treenode = myDiagram_buildUnit_selectionPane.findNodeForData(e.object);
                if (treenode !== null) treenode.updateTargetBindings();
            } 
            else if (e.change === go.ChangedEvent.Insert && e.propertyName === "nodeDataArray") {
                // pretend the new data isn't already in the nodeDataArray for myDiagram_buildUnit_selectionPane
                myDiagram_buildUnit_selectionPane.model.nodeDataArray.splice(e.newParam, 1);
                // now add to the myDiagram_buildUnit_selectionPane model using the normal mechanisms
                if(e.newValue.category === 'buildUnit'||
                    e.newValue.category === 'processingComponent' || 
                    e.newValue.category === 'sourceComponent' || 
                    e.newValue.category === 'sinkComponent' || 
                    e.newValue.category === 'fusionComponent'
                ) {
                    myDiagram_buildUnit_selectionPane.model.addNodeData(e.newValue);
                }
            } 
            else if (e.change === go.ChangedEvent.Remove && e.propertyName === "nodeDataArray") {
                // remove the corresponding node from myDiagram_buildUnit_selectionPane
                var treenode = myDiagram_buildUnit_selectionPane.findNodeForData(e.oldValue);
                if (treenode !== null) myDiagram_buildUnit_selectionPane.remove(treenode);
            }
            myChangingModel = false;
            myDiagram_buildUnit_selectionPaneTitle.requestUpdate();
            myDiagram_buildUnit_selectionPane.requestUpdate();
        });
      // SthreadTab component view
    //   myDiagram_sthread_component = $(go.Diagram, "SthreadViewer_component",
    //     {
    //         "undoManager.isEnabled": false,            
    //         "draggingTool.isEnabled": false,  
    //         "clickSelectingTool.isEnabled": false,   
    //     });

    //   myDiagram_sthread_component.nodeTemplateMap = myDiagram.nodeTemplateMap;
    //   myDiagram_sthread_component.groupTemplateMap = myDiagram.groupTemplateMap;
    //   myDiagram_sthread_component.linkTemplate = myDiagram.linkTemplate;





    //   {
    //     function togglePortAndSthread(current_diagram, obj) {
    //       var cur_shp = obj.findObject("STHREAD");
    //       var nextState;
    //       nextState = !cur_shp.toLinkable;  

    //       console.log("togglePortAndSthread:"+nextState);
    //       toggleAllStreamPort(current_diagram, obj);
    //       togglePortAndSthread_sync(current_diagram, nextState);          
    //     }

    //     function togglePortAndSthread_sync(current_diagram, nextState) {

    //       current_diagram.nodes.each(function(node) {
    //         if (node.name === "DEDICATE_STHREAD" 
    //             || node.name === "INTERNAL_STHREAD") {
    //           var shp = node.findObject("STHREAD");
    //           if(nextState === true) { 
    //             shp.toLinkable = true;
    //             shp.fromLinkable = true;
    //             shp.stroke = "#FF00FF";
    //             shp.strokeWidth = 2;
    //             console.log("togglePortAndSthread_sync: true");
    //           } else {             
    //             shp.toLinkable = false;
    //             shp.fromLinkable = false;
    //             shp.stroke = "transparent";
    //             shp.strokeWidth = 1;
    //             console.log("togglePortAndSthread_sync: false");
    //           }
    //           updateStates(current_diagram);  
    //         }
    //       });
    //       toggleAllStreamPort_sync(current_diagram, nextState);
    //     }

    //     function activatePortAndSthread(current_diagram) {
    //       togglePortAndSthread_sync(current_diagram, true);
    //     }

    //     function deactivatePortAndSthread(current_diagram) {
    //       togglePortAndSthread_sync(current_diagram, false);
    //     }

    //     function splash_sthreadNodeStyle() {
    //       return [new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
    //       new go.Binding("isShadowed", "isSelected").ofObject(),
    //       {
    //         selectionAdorned: false,
    //         shadowOffset: new go.Point(0, 0),
    //         shadowBlur: 15,
    //         shadowColor: "blue",
    //         resizable: false,
    //         toolTip: sharedToolTip,
    //         resizeObjectName: "SHAPE",
    //         visible: true,
    //         selectionChanged: function(p) {
    //           p.zOrder = (p.isSelected ? 11 : 10);
    //         },
    //       }];
    //     }

    //     function splash_sthreadShapeStyle() {
    //       return {            
    //         name: "STHREAD",
    //         desiredSize: new go.Size(80, 100),
    //         fill: "transparent",
    //         fromSpot: go.Spot.Right,
    //         fromLinkable: false,
    //         fromMaxLinks: Number.MAX_VALUE,
    //         toSpot: go.Spot.Left,
    //         toLinkable: false,
    //         toMaxLinks: 1,
    //         stroke: "transparent",
    //         cursor: "pointer",
    //       };
    //     }
                 
    //     var template_dedicatedSthread = 
    //       $(go.Node, "Spot", splash_sthreadNodeStyle(),
    //         { 
    //           name: "DEDICATE_STHREAD",
    //           zOrder : 10,  
    //         },
    //       $(go.Shape, "RoundedRectangle",
    //         {               
    //           fill: "white", stroke: "black", parameter1: 10, strokeWidth: 1.5, strokeDashArray: [5,3],
    //           width: 80, height: 100,
    //         }),
    //       $(go.Shape, "BpmnActivityAdHoc",
    //         {               
    //           fill: "white", stroke: "black", angle: 90, strokeWidth: 4, alignment: new go.Spot(0.5, 0.35), 
    //           width: 40, height: 40,
    //         }),
    //       $(go.TextBlock,
    //         {
    //           text: "Dedicated Sthread",
    //           alignment: new go.Spot(0.5, 0.75),
    //           textAlign: "center",
    //           width: 60,
    //           margin: 2,
    //           overflow: go.TextBlock.OverflowEllipsis,
    //           maxLines: 2,              
    //         },
    //       ),
    //       $(go.Shape, "RoundedRectangle", splash_sthreadShapeStyle(),                           
    //         { portId: "", parameter1: 10, strokeWidth: 1.5, alignment: new go.Spot(0.5, 0.5) },
    //       ),
    //       { doubleClick: function(e, obj) {
    //           e.diagram.startTransaction("Toggle Input");
    //           togglePortAndSthread(e.diagram,obj);
    //           e.diagram.commitTransaction("Toggle Input");
    //       }}
    //     );

        
    //     var template_internalSthread = 
    //       $(go.Node, "Spot", splash_sthreadNodeStyle(),
    //         { 
    //           name: "INTERNAL_STHREAD",
    //           zOrder : 10,  
    //         },
    //       $(go.Shape, "RoundedRectangle",
    //         {               
    //           fill: "white", stroke: "black", parameter1: 10, strokeWidth: 1.5, strokeDashArray: [5,3],
    //           width: 80, height: 100,
    //         }),
    //       $(go.Shape, "BpmnActivityAdHoc",
    //         {               
    //           fill: "white", stroke: "black", angle: 90, strokeWidth: 4, alignment: new go.Spot(0.5, 0.35), 
    //           width: 40, height: 40,
    //         }),
    //       $(go.TextBlock,
    //         {
    //           text: "Internal Sthread",
    //           alignment: new go.Spot(0.5, 0.75),
    //           textAlign: "center",
    //           width: 60,
    //           margin: 2,
    //           overflow: go.TextBlock.OverflowEllipsis,
    //           maxLines: 2,              
    //         },            
    //       ),
    //       $(go.Shape, "RoundedRectangle", splash_sthreadShapeStyle(),                           
    //         { portId: "", alignment: new go.Spot(0.5, 0.5) },
    //       ),
    //       { doubleClick: function(e, obj) {
    //           e.diagram.startTransaction("Toggle Input");
    //           togglePortAndSthread(e.diagram,obj);
    //           e.diagram.commitTransaction("Toggle Input");
    //       }}
    //     );
        
    //   }



      // SthreadTab sthread view
    //   myDiagram_sthread_sthread = $(go.Diagram, "SthreadViewer_sthread", 
    //     {
    //       "undoManager.isEnabled": true,          
    //       LinkDrawn: function(e) {
    //         console.log("LinkDrawn()");

    //         deactivatePortAndSthread(e.diagram);
    //       },
    //     });

    //   myDiagram_sthread_sthread.linkTemplate = myDiagram.linkTemplate;

    //   myDiagram_sthread_sthread.nodeTemplateMap.add("streamPort", template_streamPort);
    //   myDiagram_sthread_sthread.nodeTemplateMap.add("eventInputPort", template_eventInputPort);
    //   myDiagram_sthread_sthread.nodeTemplateMap.add("eventOutputPort", template_eventOutputPort);
    //   myDiagram_sthread_sthread.nodeTemplateMap.add("modeChangeInputPort", template_modeChangeInputPort);
    //   myDiagram_sthread_sthread.nodeTemplateMap.add("modeChangeOutputPort", template_modeChangeOutputPort); 
    //   myDiagram_sthread_sthread.nodeTemplateMap.add("dedicatedSthread", template_dedicatedSthread);
    //   myDiagram_sthread_sthread.nodeTemplateMap.add("internalSthread", template_internalSthread);


          
      // palette node templates 
      {
        var paletteTemplate_streamPort = 
              $(go.Node, "Spot",
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip,
                },
                { name: "PALETTE_STREAM_PORT", locationSpot: go.Spot.Center },
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),              
                $(go.Shape, "Rectangle",
                  { fill: "white", width:20, height:20, alignment: new go.Spot(0.25, 0.5) }),
                $(go.Shape, "TriangleRight", 
                  { fill: "black", width: 10, height: 10, alignment: new go.Spot(0.25, 0.5) }),
                $(go.TextBlock, "Stream Port", 
                  { 
                    name: "TEXT_NAME",
                    textAlign: "center",
                    alignment: new go.Spot(0.7, 0.5) 
                  }),            
              );                        

        var paletteTemplate_eventInputPort = 
              $(go.Node, "Spot",
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip
                },
                { name: "PALETTE_EVENT_INPUT_PORT", locationSpot: go.Spot.Center  },
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),              
                $(go.Shape, "Rectangle",
                  { fill: "white", width:20, height:20, alignment: new go.Spot(0.25, 0.5) }),
                $(go.Shape, "ISOProcess", 
                  { fill: "black", width: 16, height: 13, stroke: "white", angle:90, alignment: new go.Spot(0.25, 0.5) }),
                $(go.TextBlock, "Event\nInputPort", 
                  { 
                    name: "TEXT_NAME",
                    textAlign: "center",
                    alignment: new go.Spot(0.7, 0.5) }),            
              );     

        var paletteTemplate_eventOutputPort = 
              $(go.Node, "Spot",
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip
                },
                { name: "PALETTE_EVENT_OUTPUT_PORT", locationSpot: go.Spot.Center },
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),              
                $(go.Shape, "Rectangle",
                  { fill: "white", width:20, height:20, alignment: new go.Spot(0.25, 0.5) }),
                $(go.Shape, "ISOProcess", 
                  { fill: "black", width: 16, height: 13, angle: 270, stroke: "white", alignment: new go.Spot(0.25, 0.5) }),
                $(go.TextBlock, "Event\nOutputPort", 
                  { 
                    name: "TEXT_NAME",
                    textAlign: "center",                    
                    alignment: new go.Spot(0.7, 0.5) }),            
              );  
              
        var paletteTemplate_modeChangeInputPort = 
              $(go.Node, "Spot",
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip,
                },
                { name: "PALETTE_MODE_CHANGE_INPUT_PORT", locationSpot: go.Spot.Center },
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5),
                  }),              
                $(go.Shape, "Rectangle",
                  { fill: "white", width:20, height:20, alignment: new go.Spot(0.25, 0.5) }),
                $(go.Shape, "Circle", 
                  { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.25, 0.5-0.091+0.023+0.138) }),
                $(go.Shape, "Circle", 
                  { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.25-0.024, 0.5+0.046+0.023-0.138) }),
                $(go.Shape, "Circle", 
                  { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.25+0.024, 0.5+0.046+0.023-0.138) }),
                $(go.TextBlock, "ModeChange\nInputPort", 
                  { 
                    name: "TEXT_NAME",
                    textAlign: "center",                    
                    //isStrikethrough: true, // disabled palette
                    alignment: new go.Spot(0.7, 0.5) }),            
              );                   

        var paletteTemplate_modeChangeOutputPort = 
              $(go.Node, "Spot",
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip,
                },
                { name: "PALETTE_MODE_CHANGE_OUTPUT_PORT", locationSpot: go.Spot.Center },
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5),
                  }),              
                $(go.Shape, "Rectangle",
                  { fill: "white", width:20, height:20, alignment: new go.Spot(0.25, 0.5) }),
                $(go.Shape, "Circle", 
                  { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.25, 0.5-0.091+0.023) }),
                $(go.Shape, "Circle", 
                  { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.25-0.024, 0.5+0.046+0.023) }),
                $(go.Shape, "Circle", 
                  { fill: "black", width: 4, height: 4, stroke: null, alignment: new go.Spot(0.25+0.024, 0.5+0.046+0.023) }),
                $(go.TextBlock, "ModeChange\nOutputPort", 
                  { 
                    name: "TEXT_NAME",
                    textAlign: "center",
                    //isStrikethrough: true, // disabled palette
                    alignment: new go.Spot(0.7, 0.5) }),            
              ); 

        var paletteTemplate_processingComponent =
              $(go.Group, "Spot",
                { name: "PALETTE_PROCESSING_COMPONENT", locationSpot: go.Spot.Center },
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip
                },                
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),              
                $(go.Shape, "Rectangle",
                  { fill: "white", width:40, height:40, alignment: new go.Spot(0.25, 0.5) }),
                $(go.TextBlock, "Processing\nComponent", 
                  { textAlign: "center",
                    alignment: new go.Spot(0.7, 0.5) }),              
              );         

        var paletteTemplate_sourceComponent = 
              $(go.Node, "Spot",
                { name: "PALETTE_SOURCE_COMPONENT", locationSpot: go.Spot.Center },
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip
                },                
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),       
                $(go.Shape, "Rectangle",
                  { fill: "white", width:64, height:32, alignment: new go.Spot(0.25, 0.5) }),                  
                $(go.Shape, "Rectangle",
                  { fill: "white", width:16, height:16, alignment: new go.Spot(0.428, 0.5) }),
                $(go.Shape, "TriangleRight", 
                  { fill: "black", width:8, height:8, alignment: new go.Spot(0.428, 0.5) }),
                $(go.TextBlock, "Source\nComponent", 
                  { textAlign: "center",
                    alignment: new go.Spot(0.7, 0.5) }),      
              );         
        
        var paletteTemplate_sinkComponent =
              $(go.Node, "Spot",
                { name: "SINK_COMPONENT", locationSpot: go.Spot.Center },
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip
                },                
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),       
                $(go.Shape, "Rectangle",
                  { fill: "white", width:64, height:32, alignment: new go.Spot(0.284, 0.5) }),                  
                $(go.Shape, "Rectangle",
                  { fill: "white", width:16, height:16, alignment: new go.Spot(0.106, 0.5) }),
                $(go.Shape, "TriangleRight", 
                  { fill: "black", width: 8, height: 8, alignment: new go.Spot(0.106, 0.5) }),
                $(go.TextBlock, "Sink\nComponent", 
                  { textAlign: "center",
                    alignment: new go.Spot(0.7, 0.5) }),            
              ); 
        
        var paletteTemplate_fusionOperator =
              $(go.Group, "Spot",
                { name: "PALETTE_FUSION_COMPONENT", locationSpot: go.Spot.Center },
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip
                },                
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),              
                $(go.Shape, "Trapezoid",
                  { fill: "white", width:40, height:25, angle: 90, alignment: new go.Spot(0.25, 0.5) }),
                $(go.TextBlock, "Fusion\nComponent", 
                  { textAlign: "center",
                    alignment: new go.Spot(0.7, 0.5) }),              
              );
        
        var paletteTemplate_factory =
              $(go.Group, "Spot",
                { name: "PALETTE_FACTORY", locationSpot: go.Spot.Center },
                new go.Binding("isShadowed", "isSelected").ofObject(),
                {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: "blue",
                  resizable: true,
                  resizeObjectName: "SHAPE",
                  toolTip: sharedToolTip
                },
                $(go.Shape, "RoundedRectangle",
                  { fill: $(go.Brush, "Linear", { 0.0: "white", 1.0: "gray" }),
                    width: 180, height: 55, stroke: "black", strokeWidth: 1,
                    parameter1: 5,
                    alignment: new go.Spot(0.5, 0.5)
                  }),              
                $(go.Shape, "RoundedRectangle",
                  { fill: "white", width:80, height:40, parameter1: 10, alignment: new go.Spot(0.3, 0.5) }),
                $(go.TextBlock, "Factory", 
                  { textAlign: "center",
                    alignment: new go.Spot(0.7, 0.5) }),              
              );  
      }
      
      // share the template map with the Palette
      palette.nodeTemplateMap.add("streamPort", paletteTemplate_streamPort);  
      palette.nodeTemplateMap.add("eventInputPort", paletteTemplate_eventInputPort);  
      palette.nodeTemplateMap.add("eventOutputPort", paletteTemplate_eventOutputPort);  
      palette.nodeTemplateMap.add("modeChangeInputPort", paletteTemplate_modeChangeInputPort); 
      palette.nodeTemplateMap.add("modeChangeOutputPort", paletteTemplate_modeChangeOutputPort); 
      palette.groupTemplateMap.add("processingComponent", paletteTemplate_processingComponent);  
      palette.groupTemplateMap.add("sourceComponent", paletteTemplate_sourceComponent);   
      palette.groupTemplateMap.add("sinkComponent", paletteTemplate_sinkComponent);   
      palette.groupTemplateMap.add("fusionOperator", paletteTemplate_fusionOperator); 
      palette.groupTemplateMap.add("factory", paletteTemplate_factory);
      
      palette.layout = $(go.GridLayout, { alignment: go.GridLayout.Location, spacing: new go.Size(5,8)});

      palette.model.makeUniqueKeyFunction = setKeyUUID;
      palette.maxSelectionCount = 1;
      
      palette.model.nodeDataArray = [
        { category: "streamPort" },
        { category: "eventInputPort" },
        { category: "eventOutputPort" },
        { category: "modeChangeInputPort" },
        { category: "modeChangeOutputPort" },
        { category: "processingComponent", "isGroup": true },  
        { category: "sourceComponent", "isGroup": true},
        { category: "sinkComponent", "isGroup": true },
        { category: "fusionOperator", "isGroup": true },
        { category: "factory", "isGroup": true },
      ];
  

    //   {
                 
    //     var paletteTemplate_dedicatedSthread = 
    //       $(go.Node, "Spot",
    //         { 
    //           name: "PALETTE_DEDICATE_STHREAD",
    //           zOrder : 10,  
    //         },
    //       $(go.Shape, "RoundedRectangle",
    //         {               
    //           fill: "white", stroke: "black", parameter1: 10, strokeWidth: 1.5, strokeDashArray: [5,3],
    //           width: 80, height: 100,
    //         }),
    //       $(go.Shape, "BpmnActivityAdHoc",
    //         {               
    //           fill: "white", stroke: "black", angle: 90, strokeWidth: 4, alignment: new go.Spot(0.5, 0.35), 
    //           width: 40, height: 40,
    //         }),
    //       $(go.TextBlock,
    //         {
    //           text: "Dedicated Sthread",
    //           alignment: new go.Spot(0.5, 0.75),
    //           textAlign: "center",
    //           width: 60,
    //           margin: 2,
    //           overflow: go.TextBlock.OverflowEllipsis,
    //           maxLines: 2,
              
    //         },
    //       )
    //     );

    //     var paletteTemplate_internalSthread = 
    //       $(go.Node, "Spot",
    //         { 
    //           name: "PALETTE_INTERNAL_STHREAD",
    //           zOrder : 10,  
    //         },
    //       $(go.Shape, "RoundedRectangle",
    //         {               
    //           fill: "white", stroke: "black", parameter1: 10, strokeWidth: 1.5, strokeDashArray: [5,3],
    //           width: 80, height: 100,
    //         }),
    //       $(go.Shape, "BpmnActivityAdHoc",
    //         {               
    //           fill: "white", stroke: "black", angle: 90, strokeWidth: 4, alignment: new go.Spot(0.5, 0.35), 
    //           width: 40, height: 40,
    //         }),
    //       $(go.TextBlock,
    //         {
    //           text: "Internal Sthread",
    //           alignment: new go.Spot(0.5, 0.75),
    //           textAlign: "center",
    //           width: 60,
    //           margin: 2,
    //           overflow: go.TextBlock.OverflowEllipsis,
    //           maxLines: 2,
              
    //         },
    //       )
    //     );
    //   }




    //   var palette_sthread = new go.Palette("palette_sthread");
      
    //   palette_sthread.nodeTemplateMap.add("dedicatedSthread", paletteTemplate_dedicatedSthread); 
    //   palette_sthread.nodeTemplateMap.add("internalSthread", paletteTemplate_internalSthread); 

    //   palette_sthread.layout = $(go.GridLayout, { alignment: go.GridLayout.Location, spacing: new go.Size(5,8)});

    // //   palette_sthread.model.makeUniqueKeyFunction = setKeyUUID;
    //   palette_sthread.maxSelectionCount = 1;

    //   palette_sthread.model.nodeDataArray = [
    //     { category: "dedicatedSthread" },
    //     { category: "internalSthread" },
        
    //   ];


    // build unit and fusion operator view window
    // myDiagram.addDiagramListener("ChangedSelection", function(diagramEvent) {
    //     var idrag_buildUnit = document.getElementById("infoDraggable_buildUnit");
    //     var idrag_fusionOperator = document.getElementById("infoDraggable_fusionOperator");
    // });



    //
    function setKeyUUID(model, data) {
        console.log("NEW setKeyUUID");
        var new_name = ""
        var name_count = 1;
        // var new_key = createKeyUUID();
        if(data.category === "processingComponent") {
            do {
                new_name = "processing_component_" + name_count;
                name_count = name_count + 1;
                console.log(new_name);
            }while(model.findNodeDataForKey(new_name) !== null);
        }
        else if(data.category === "sourceComponent") {
            do {
                new_name = "source_component_" + name_count;
                name_count = name_count + 1;
            }while(model.findNodeDataForKey(new_name) !== null);
        }
        else if(data.category === "fusionOperator") {
            do {
                new_name = "fusion_operator_" + name_count;
                name_count = name_count + 1;
            }while(model.findNodeDataForKey(new_name) !== null);
        }
        else if(data.category === "factory") {
            do {
                new_name = "factory_" + name_count;
                name_count = name_count + 1;
            }while(model.findNodeDataForKey(new_name) !== null);
        }
        else if(data.category === "buildUnit") {
            new_name = data.text;
        }
        return new_name;
    //   if (data.key === undefined || model.findNodeDataForKey(data.key) !== null) {
    //     console.log("YES NEW KEY");
    //     var new_name = ""
    //     var name_count = 1;
    //     // var new_key = createKeyUUID();
    //     do {
    //         new_name = "processing_component_" + name_count;
    //         name_count += 1;
    //     }while(checkIfNameExists(new_name));
    //     console.log(new_name)
    //     return new_name
    //   } else {
    //     console.log("else?");
    //     return "";
    //   }
    }
    
    // inspector code
    {
      function getCurrentObjectName() {
        if(externalDroppedObjectName === "NONE") {
          return internalSelectedObjectName;
        } else {
          return externalDroppedObjectName;
        }
      }
      
      function isProcessingComponent() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "PROCESSING" ? true : false);
      }

      function isSourceComponent() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "SOURCE" ? true : false);
      }

      function isSinkComponent() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "SINK" ? true : false);
      }
      
      function isStreamInputPort() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "STREAM_INPUT_PORT" ? true : false);
      }

      function isStreamOutputPort() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "STREAM_OUTPUT_PORT" ? true : false);
      }
      
      function isStreamDelegationPort() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "STREAM_DELEGATION_PORT" ? true : false);
      }
      
      function isFusionOperator() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "FUSION" ? true : false);
      }
      
      function isFactory() {
        var currentObjectName = getCurrentObjectName();
        return (currentObjectName === "FACTORY" ? true : false);
      }

      function isStreamPort() {
        var currentObjectName = getCurrentObjectName();
        return(currentObjectName === "STREAM_UNTYPED_PORT" || (isStreamInputPort() || isStreamOutputPort() || isStreamDelegationPort()));
      }
      function isNotStreamPort() {
        var currentObjectName = getCurrentObjectName();
        return !(currentObjectName === "STREAM_UNTYPED_PORT" || (isStreamInputPort() || isStreamOutputPort() || isStreamDelegationPort()));
      }
      function isChannel(part) {
        return part instanceof go.Link;
      }

      function hasDataType(part) {
        return (isStreamPort() || isChannel(part));
      }

      function hasFreshness() {
        return isSourceComponent();
      }
      
      function hasRate() {
        return (isStreamOutputPort()||isStreamDelegationPort());
      }

      function canResize() {
      	return (isProcessingComponent() || isFactory() || isFusionOperator());
      }

      function isComponent() {
        return (isProcessingComponent() || isSourceComponent() || isSinkComponent() || isFusionOperator() || isFactory());
      }

      function isNotComponent() {
        return !isComponent();
      }

      var inspector = new Inspector('splashInspectorDiv', myDiagram,
        {

          // uncomment this line to only inspect the named properties below instead of all properties on each object:
          includesOwnProperties: false,
          multipleSelection: true,
          propertyModified: function(prop, new_value, inspector) {
            var node = inspector.inspectedObject; 
            console.log('propertyModefied')
          },
          properties: {
            "buildUnit": {
              readOnly: isNotComponent,
              multipleSelection: true,
              type: "select",
              choices: function(node, propName) {
                var options_buildUnit = document.getElementById("select_buildUnit");
                var options_choices = [];
                options_choices[0] = "";

                for(i=0; i<options_buildUnit.length; ++i) {
                  options_choices[i+1] = options_buildUnit[i].text;              
                }
                return options_choices;
              }
            },

            "DataType": {readOnly: isChannel, show: hasDataType},

            "Freshness": {show: hasFreshness, type: "number"},
            "Rate": {show: hasRate, type: "number"},



            "COMMENTS": {},              
          }
        });

      
      var inspector2 = new Inspector('splashInspectorDiv2', myDiagram,
        {
          // uncomment this line to only inspect the named properties below instead of all properties on each object:
          includesOwnProperties: false,
          propertyModified: function(prop, new_value, inspector) {
            console.log("inspector2 propertyModified");
            var node = inspector.inspectedObject; 

            var shape = node.findObject("SHAPE");
            //shape.fill = node.data.color;
          },
          properties: {
            "category": {readOnly: true},            
            "PORT_TYPE": {readOnly: true,  show: isStreamPort },
            "key": { readOnly: true, show: isNotStreamPort },
            "group": { readOnly: true, show: Inspector.showIfNode },
            "isGroup": { show: false },

            "loc": {},
            "WIDTH": { show: canResize },
            "HEIGHT": { show: canResize } ,

            "to": { readOnly: true, show: Inspector.showIfPresent},
            "from": { readOnly: true, show: Inspector.showIfPresent},
            "segArray" : { show: Inspector.showIfLink },
          }
        });      
    }
    
    var openFile;
    function handleOpenFile(evt) {
        openFile = evt.target.files[0]; // a file object

        var readString;

        var reader = new FileReader();
        reader.onload = function(event) {
            //console.log('File content:', event.target.result);
            readString = event.target.result.substring(0);

            //var 
            //var string_GraphLinksModel = 

            //console.log(readString);
            myDiagram.model = go.Model.fromJson(readString);
            
            var parsedString = JSON.parse(readString);   
            // buildUnitArray = parsedString.buildUnitArray;
            // readBuildUnitProperty();
            //console.log(myDiagram.model.nodeDataArray);
            //console.log(myDiagram.model.linkDataArray);

            //var parsedString = JSON.parse(readString);          
            //console.log(parsedString.buildUnitArray);


            //console.log("OPEN?"+readString);
        };
        reader.readAsText(openFile);
        var fileName = openFile.name.substring(0,openFile.name.length-5);

        setCurrentFileName(fileName);



        forceSelectTab('SchematicTab');      
        // share all of the data with the tree view
        myDiagram_buildUnit_selectionPane.model.nodeDataArray = myDiagram.model.nodeDataArray;

        // share the UndoManager too!
        myDiagram_buildUnit_selectionPane.model.undoManager = myDiagram.model.undoManager;
        myDiagram.requestUpdate();
        myDiagram_buildUnit.requestUpdate();
        myDiagram_buildUnit_selectionPane.requestUpdate();
    }
              
    // the Overview
    myOverview =
      $(go.Overview, "overviewDiv",
        { observed: myDiagram, maxScale: 0.5 });
        // change color of viewport border in Overview
    myOverview.box.elt(0).stroke = "dodgerblue";

    // the Overview_bulidUnit
    myOverview_bulidUnit =
      $(go.Overview, "overviewDiv_buildUnit",
        { observed: myDiagram_buildUnit, maxScale: 0.5 });
        // change color of viewport border in Overview
    myOverview_bulidUnit.box.elt(0).stroke = "dodgerblue";
    
    
    startLogConsole();
    
    //newDocument();
    
    // continually update the diagram
    var m_pos;
    function resizeSelectionPane(e) {
        var dx = m_pos - e.x;
        m_pos = e.x;
        var panel = document.getElementById("selectionPaneWrapper");
        panel.style.width = (parseInt(getComputedStyle(panel, '').width) + dx) + "px";
        myDiagram_buildUnit.requestUpdate();
        myDiagram_buildUnit_selectionPaneTitle.requestUpdate();
        myDiagram_buildUnit_selectionPane.requestUpdate();
    }
    document.getElementById("fileOpenMenu").addEventListener("change", handleOpenFile, false);
    document.getElementById("resizeBorder").addEventListener("mousedown", function(e) {
        e.preventDefault();
        document.addEventListener("mousemove", resizeSelectionPane, false);
    }, false);
    document.addEventListener("mouseup", function() {
        document.removeEventListener("mousemove", resizeSelectionPane, false);
    }, false);

    

    var arr = myDiagram.model.nodeDataArray;
    for (var i = 0; i < arr.length; i++) {
        var data = arr[i];
        var buildUnit = data.buildUnit;
        if (buildUnit) {
            var sdata = myDiagram.model.findNodeDataForKey(buildUnit);
            if (sdata) {
                // update _supers to be an Array of references to node data
                if (!data._buildUnit) {
                    data._buildUnit = [sdata];
                } else {
                    data._buildUnit.push(sdata);
                }
                // update _members to be an Array of references to node data
                if (!sdata._members) {
                    sdata._members = [data];
                } else {
                    sdata._members.push(data);
                }
            }
        }
    }
    loop();  
      
      
      
      
      
    } // end of init()
    
    
    function notAssigned_buildUnit(BuildUnit) {
      if(BuildUnit === undefined || BuildUnit === "") return true;
    }

    // enable or disable a particular button
    function enable(name, ok) {
      var button = document.getElementById(name);
      if (button) button.disabled = !ok;
    }
    
    function enableAll() {
        var cmdhnd = myDiagram.commandHandler;
        
/*      enable("Rename", myDiagram.selection.count > 0);
      enable("Undo", cmdhnd.canUndo());
      enable("Redo", cmdhnd.canRedo());
      enable("Cut", cmdhnd.canCutSelection());
      enable("Copy", cmdhnd.canCopySelection());
      enable("Paste", cmdhnd.canPasteSelection());
      enable("Delete", cmdhnd.canDeleteSelection());
      enable("SelectAll", cmdhnd.canSelectAll());
      enable("AlignLeft", cmdhnd.canAlignSelection());
      enable("AlignRight", cmdhnd.canAlignSelection());
      enable("AlignTop", cmdhnd.canAlignSelection());
      enable("AlignBottom", cmdhnd.canAlignSelection());
      enable("AlignCenterX", cmdhnd.canAlignSelection());
      enable("AlignCenterY", cmdhnd.canAlignSelection());
      enable("AlignRow", cmdhnd.canAlignSelection());
      enable("AlignColumn", cmdhnd.canAlignSelection());
      enable("AlignGrid", cmdhnd.canAlignSelection());
      enable("Rotate45", cmdhnd.canRotate(45));
      enable("Rotate_45", cmdhnd.canRotate(-45));
      enable("Rotate90", cmdhnd.canRotate(90));
      enable("Rotate_90", cmdhnd.canRotate(-90));
      enable("Rotate180", cmdhnd.canRotate(180));*/
    }
    
    
/*    function askSpace() {
      var space = alert("Desired space between nodes (in pixels):", "0");
      return space;
    }
    */
    



    
    // update the diagram every 250 milliseconds
    function loop() {
      setTimeout(function() { 
        document.getElementById("programTitle").innerHTML 
          = document.getElementById("currentFile").innerHTML
            + "\xa0\xa0\xa0-\xa0\xa0\xa0"
            + document.getElementById("programName").innerHTML
            + "\xa0\xa0"
            + document.getElementById("version").innerHTML;
        updateStates(myDiagram); 
        loop(); 
      }, 250);
    }
    // update the value and appearance of each node according to its type and input values
    function updateStates(current_diagram) {
      var oldskip = current_diagram.skipsUndoManager;
      current_diagram.skipsUndoManager = true;
      // do all "input" nodes first
      current_diagram.nodes.each(function(node) {
        if (node.category === "input") {
          doInput(node);
        }
      });
      // now we can do all other kinds of nodes
      current_diagram.nodes.each(function(node) {
        switch (node.category) {
          case "and": doAnd(node); break;
          case "or": doOr(node); break;
          case "xor": doXor(node); break;
          case "not": doNot(node); break;
          case "nand": doNand(node); break;
          case "nor": doNor(node); break;
          case "xnor": doXnor(node); break;
          case "output": doOutput(node); break;
          case "input": break;  // doInput already called, above
        }
      });
      current_diagram.skipsUndoManager = oldskip;
    }
    // // helper predicate
    // function linkIsTrue(link) {  // assume the given Link has a Shape named "SHAPE"
    //   return link.findObject("SHAPE").stroke === green;
    // }
    // // helper function for propagating results
    // function setOutputLinks(node, color) {
    //   node.findLinksOutOf().each(function(link) { link.findObject("SHAPE").stroke = color; });
    // }
    
   
    // shows/hides gridlines
    // to be implemented onclick of a button
    function updateGridOption() {
      myDiagram.startTransaction("grid");
      var grid = document.getElementById("grid");
      myDiagram.grid.visible = (grid.checked === true);
      myDiagram.commitTransaction("grid");
    }

    // enables/disables guidelines when dragging
    function updateGuidelinesOption() {
      // no transaction needed, because we are modifying a tool for future use
      var guide = document.getElementById("guidelines")
      if (guide.checked === true) {
        myDiagram.toolManager.draggingTool.isGuidelineEnabled = true;
      } else {
        myDiagram.toolManager.draggingTool.isGuidelineEnabled = false;
      }
    }
    

  $(function() {
    var firstTime = true;
    $("#tabs").tabs({
      activate: function(event, ui) {
        // Needed the first time you tab to a tab with a Diagram in it,
        // because the diagram in the tab had zero size while initializing:
        if (firstTime) {
          myDiagram.delayInitialization(function() { myDiagram.requestUpdate(); });
          myDiagram_buildUnit.delayInitialization(function() { myDiagram_buildUnit.requestUpdate(); });
        //   myDiagram_sthread_component.delayInitialization(function() { myDiagram_sthread_component.requestUpdate(); });
        //   myDiagram_sthread_sthread.delayInitialization(function() { myDiagram_sthread_sthread.requestUpdate(); });
          firstTime = false;
        }
        // every time after you need nothing, or in case the Diagram div changed size, this:
        myDiagram.requestUpdate();
        myDiagram_buildUnit.requestUpdate();
        myDiagram_buildUnit_selectionPane.requestUpdate();
      }
    });


    // build unit view window
    $("#infoDraggable_buildUnit").draggable({ handle: "#infoDraggableHandle_buildUnit" });

    // fusion opeartor view window
    $("#infoDraggable_fusionOperator").draggable({ handle: "#infoDraggableHandle_fusionOperator" });

    
    console.log("call init()");
    init();    
  });  


  </script>
  
  <script>
    function updateProperty() {
      myDiagram.selection.each(function(part) {
        // 1. relocatePort(part)
        var it_memberParts;
        var memeber_port;

        if(part.name == "SOURCE") {
          it_memberParts = part.memberParts;
          memeber_port = it_memberParts.first()

          memeber_port.location = new go.Point(part.location.x+30, part.location.y-part.actualBounds.height/2+10);
          console.log(memeber_port.location);

        } else if(part.name == "SINK") {
          it_memberParts = part.memberParts;
          memeber_port = it_memberParts.first()

          memeber_port.location = new go.Point(part.location.x-50, part.location.y-part.actualBounds.height/2+10);

        } else {}

        // 2. inheritBuildUnit(part)


      });



      addLog("Update property");
    }

    function checkSyntax_buildUnit() {
      var isPass = true;
      myDiagram.nodes.each(function(node){
        // 1. atomic component
        if(node.name === "SOURCE"
        || node.name === "SINK"
        || node.name === "PROCESSING"
        || node.name === "FUSION") {
          // 1-1. Not assigned

          if(notAssigned_buildUnit(node.data.buildUnit)) {
            isPass = false;
            addLog("[SYNTAX ERROR (BuildUnit)] "
              +"Atomic component :"+node.key+"("+node.data.buildUnit+") "
              +"is not assigned.");
          } // 1-2. Incompatible with the superset factory
          else if(node.containingGroup !== null) {
            if(node.data.buildUnit !== node.containingGroup.data.buildUnit
              && !notAssigned_buildUnit(node.containingGroup.data.buildUnit)) { 
              if(node.containingGroup.data.buildUnit != "") {
                isPass = false;
                addLog("[SYNTAX ERROR (BuildUnit)] "
                  +"Atomic component "+node.key+"("+node.data.buildUnit+") and "
                  +"factory "+node.containingGroup.key+"("+node.containingGroup.data.buildUnit+") "
                  +"are incompatible.");
              }
            }
          }
          else if(node.containingGroup === null) {
            if(node.name === "PROCESSING" || node.name === "FUSION") {
              isPass = false;
              addLog("[SYNTAX ERROR (BuildUnit)] "
                +"Atomic component: "+node.key+" cannot exist independently");
            }
          }

        }
        // 2. factory
        else if(node.name === "FACTORY") {
          // Incompatible with the superset factory
          if(node.containingGroup !== null) {
            if(node.data.buildUnit !== node.containingGroup.data.buildUnit
              && !notAssigned_buildUnit(node.containingGroup.data.buildUnit)) { 
              if(node.containingGroup.data.buildUnit != "") {
                isPass = false;
                addLog("[SYNTAX ERROR (BuildUnit)] "
                  +"Factory "+node.key+"("+node.data.buildUnit+") and "
                  +"factory "+node.containingGroup.key+"("+node.containingGroup.data.buildUnit+") "
                  +"are incompatible.");
              }
            }
          }
        }
        // 3. port
        else {
          // 3-1. Not assgined 
          if(notAssigned_buildUnit(node.data.buildUnit)) {
            if(node.containingGroup.name === "FACTORY") {               
              if(!notAssigned_buildUnit(node.containingGroup.data.buildUnit)) {
                isPass = false;
                addLog("[SYNTAX ERROR (BuildUnit)] "
                  +"Port :"+node.key+"("+node.data.buildUnit+") "
                  +"is not assigned.");
              }
            } else {
              isPass = false;
              addLog("[SYNTAX ERROR (BuildUnit)] "
                +"Port :"+node.key+"("+node.data.buildUnit+") "
                +"is not assigned.");
            }
          }
          // 3-2. Incompatible with the superset component
          if(node.containingGroup !== null) {
            if(node.data.buildUnit !== node.containingGroup.data.buildUnit
              && !notAssigned_buildUnit(node.containingGroup.data.buildUnit)) { 
              if(node.containingGroup.data.buildUnit != "") {
                isPass = false;
                addLog("[SYNTAX ERROR (BuildUnit)] "
                  +"Port "+node.key+"("+node.data.buildUnit+") and "
                  +"component "+node.containingGroup.key+"("+node.containingGroup.data.buildUnit+") "
                  +"are incompatible.");
              }
            }
          } else {
            isPass = false;
            addLog("[SYNTAX ERROR (BuildUnit)] "
              +"Port: "+node.key+" cannot exist independently");
          }
        }
      });

      // 4. channel
      myDiagram.links.each(function(link){
        if(link.fromNode.data.buildUnit === link.toNode.data.buildUnit
          && !notAssigned_buildUnit(link.fromNode.data.buildUnit)
          && !notAssigned_buildUnit(link.toNode.data.buildUnit)) {
          if(link.data.buildUnit !== link.fromNode.data.buildUnit) {
            isPass = false;
            addLog("[SYNTAX ERROR (BuildUnit)] "
              +"Channel: "
              +"from port"+link.fromNode.key+"("+link.fromNode.data.buildUnit+") and "
              +"to port"+link.toNode.key+"("+link.toNode.data.buildUnit+") "
              +"are in the same build unit, but the build unit of channel is incompatible.");
          }
        }
      });
      if(isPass) {
        //addLog("Pass the build unit syntax check (1 of 2): individual check");
        addLog("Compelete the build unit syntax check");
      }
      else {
        addLog("Fail to pass the build unit syntax check");
        //addLog("Fail to pass the build unit syntax check (1 of 2): individual check");
        //addLog("Stop the build unit syntax check (1 of 2): individual check");
        return;
      }
    }
  </script>


  <script>
  
    var splash_logArray= ["---------------RTOS Splash Schematic Editor--------------"];
    
    function logConsole() {
      document.getElementById("splash_logConsol").innerHTML = splash_logArray;
    }
    
    function addLog(string_log) {
      var d = new Date();    
      splash_logArray.push("[" + d.toISOString() + "] " + string_log);
      updateLog();
    }
    
    function startLogConsole() {
      var d = new Date(); 
      var textarea = document.getElementById("splash_logConsol");
      textarea.innerHTML = splash_logArray + "\n";
      
      var startLog = "Start the program"
      
      splash_logArray.push("[" + d.toISOString() + "] " + startLog);   
      updateLog();
    }
    
    function updateLog() {
      var textarea = document.getElementById("splash_logConsol");
      textarea.innerHTML += splash_logArray[splash_logArray.length-1] + "\n";
      textarea.scrollTop = textarea.scrollHeight;
    }
    
    function createKeyUUID() {
      return 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });       
    }
    
    function newDocument() {
      var curFile = document.getElementById("currentFile");
      var curFileName = curFile.textContent.substring(0);

      if (myDiagram.isModified) {
        var save = confirm("Would you like to save changes to " + curFileName + "?");
        if (save) {
          saveDocument();
        }
      }
      setCurrentFileName(UnsavedFileName);
      myDiagram.div = null;
      myDiagram = null;

      palette.div = null;
      palette = null;

      myDiagram_buildUnit.div = null;
      myDiagram_buildUnit = null;

      myDiagram_buildUnit_selectionPane.div = null;
      myDiagram_buildUnit_selectionPane = null;

      myDiagram_buildUnit_selectionPaneTitle.div = null;
      myDiagram_buildUnit_selectionPaneTitle = null;

      myDiagram_sthread_component.div = null;
      myDiagram_sthread_component = null;

      myDiagram_sthread_sthread.div = null;
      myDiagram_sthread_sthread = null;

      myOverview.div = null;
      myOverview_bulidUnit.div = null;

      init();
    //   // loads an empty diagram
    //   myDiagram.model = new go.GraphLinksModel();
    //   myDiagram.undoManager.isEnabled = true;
     
    //   // share all of the data with the tree view
      
    //   myDiagram_buildUnit_selectionPane.model.nodeDataArray = myDiagram.model.nodeDataArray;

    //   // share the UndoManager too!
    //   myDiagram_buildUnit_selectionPane.model.undoManager = myDiagram.model.undoManager;
    //   curFile.textContent = "(NEW_FILENAME)";
    //   myDiagram.isModified = false;
    }

    function openDocument() {
        var curFile = document.getElementById("currentFile");
        var curFileName = curFile.textContent.substring(0);

        if (myDiagram.isModified) {
            var save = confirm("Would you like to save changes to " + curFileName + "?");
            if (save) {
            saveDocument();
            }
        }
        $("#fileOpenMenu").trigger("click");
        
    }


    function saveDocument() {
      var saveName = getCurrentFileName();
      if (saveName === UnsavedFileName) {
        saveAsDocument();0
      } else {
        setCurrentFileName(saveName);      

        var string_SplashModel = SplashModelToString();
        myDiagram.isModified = false;

        var blob = new Blob([string_SplashModel], {type: "application/json"});
        saveAs(blob, getCurrentFileName()+".json");
      }
    }

    function saveAsDocument() {
      var saveName = prompt("Save file as...", getCurrentFileName());

      if (saveName && saveName !== UnsavedFileName) {
        setCurrentFileName(saveName);      

        var string_SplashModel = SplashModelToString();
        myDiagram.isModified = false;

        var blob = new Blob([string_SplashModel], {type: "application/json"});
        saveAs(blob, getCurrentFileName()+".json");
      }
    }

    // enables/disables snapping tools, to be implemented by buttons
    function updateSnapOption() {
      // no transaction needed, because we are modifying tools for future use
      var snap = document.getElementById("snap");
      if (snap.checked === true) {
        myDiagram.toolManager.draggingTool.isGridSnapEnabled = true;
        myDiagram.toolManager.resizingTool.isGridSnapEnabled = true;
      } else {
        myDiagram.toolManager.draggingTool.isGridSnapEnabled = false;
        myDiagram.toolManager.resizingTool.isGridSnapEnabled = false;
      }
    }



    var UnsavedFileName = "(NEW_FILENAME)";

    function getCurrentFileName() {
      var currentFile = document.getElementById("currentFile");
      var name = currentFile.textContent;
      if (name[name.length - 1] === "*") return name.substr(0, name.length - 1);
      return name;
    }

    function setCurrentFileName(name) {
      var currentFile = document.getElementById("currentFile");
      if (myDiagram.isModified) {
        name += "*";
      }
      currentFile.textContent = name;
    }

  </script>


  <script>
  var about = document.getElementById("devInfo");
  //var btn = document.getElementById("aboutMenu");
  var span = document.getElementsByClassName("closeAboutBox")[0];

  function developmentInfo() {
   document.getElementById("devInfo").style.display = "block";
   //addLog("Open aboutMenu");
  }

  function aboutClose() {
    document.getElementById("devInfo").style.display = "none";
  }

  window.onclick = function(event) {
    if (event.target == document.getElementById("devInfo")) {
      document.getElementById("devInfo").style.display = "none";
    }
  }

  </script>
  
<script>
  window.onbeforeunload = function() {  
    return true;
  }
</script>



<script>
// build unit
// A custom layout that sizes each "Super" node to be big enough to cover all of it member nodes
    

// var buildUnitArray = [];

function SplashModelToString() {
  var currentModel = myDiagram.model.toJson();
  var currentModel_removeTail = currentModel.substring(0,currentModel.length-1);
  //var buildUnitString = JSON.stringify(buildUnitArray);
//   console.log(buildUnitArray);
  //console.log(buildUnitString);

//   var buildUnitString = buildUnitArrayToString();
//   currentModel = currentModel_removeTail.concat(buildUnitString);

  return currentModel;
}

function buildUnitArrayToString() {
  var pre_format = ",\n  \"buildUnitArray\":";
  var post_format = "}";
  var buildUnitString = JSON.stringify(buildUnitArray);

  console.log(buildUnitArray);
  console.log(buildUnitString);

  var formattedString = pre_format;  
  formattedString = formattedString.concat(buildUnitString);
  formattedString = formattedString.concat(post_format);

  return formattedString;
}

function readBuildUnitProperty() {
  var select_buildUnit = document.getElementById("select_buildUnit");
  var new_option;

  var i,j;
  var alreadyExist = false;

  for(i=0; i<buildUnitArray.length; ++i) {
    new_option = document.createElement("option");
    new_option.text = buildUnitArray[i].name;
    new_option.value = 1;
    select_buildUnit.add(new_option);    
  }
}

// build unit view window
function addBuildUnit() {
  var options = document.getElementById("select_buildUnit");
  var new_option = document.createElement("option");

  var new_buildUnitName = document.getElementById("newName_buildUnit").value;

  new_option.value = 1; // display option, default is on
  new_option.text = new_buildUnitName;

  if(new_option.text === null || new_option.text === undefined || new_option.text === "") {
    addLog("There are no build unit name");
    return;   
  }

  for(i=0; i<options.length; ++i) {
    if(new_option.text == options[i].text) {
      addLog("There are the same build unit name: "+new_option.text);
      return;    
    }
  }
  addLog("Add new build unit");
  options.add(new_option);
  //updateStates(myDiagram);

  // add buildUnit item to json format array
  var json_buildUnit = {"name":new_buildUnitName, "Components":[], "Color":"#ffffff"};
  buildUnitArray.push(json_buildUnit);
  console.log(buildUnitArray);
}

function removeBuildUnit() {
  var select = document.getElementById("select_buildUnit");
  var selected = select[select.selectedIndex];

  var buildUnitName = selected.text;

  // remove current showing info
  document.getElementById("selectedInfo_buildUnit_name").value = "";
  document.getElementById("selectedInfo_buildUnit_view").checked = false;

  select.remove(select.selectedIndex);
  //updateStates(myDiagram);

  // remove buildUnit item to json format array
  var i;
  for(i=0; i<buildUnitArray.length; ++i) {
    if(buildUnitArray[i].name == buildUnitName) {
      delete buildUnitArray[i];
    }
  }

  // remove empty space
  var temp_array = buildUnitArray.filter(value => Object.keys(value).length !== 0);
  buildUnitArray = temp_array;

  console.log(buildUnitArray);

}

function infoBuildUnit() {
  var select = document.getElementById("select_buildUnit");
  var selected = select[select.selectedIndex];
  var buildUnit_name = selected.text;

  // 1. get name
  document.getElementById("selectedInfo_buildUnit_name").value = buildUnit_name;

  // 2. get view option
  if(selected.value == 0) {
    console.log("selected.value is " +selected.value);
    document.getElementById("selectedInfo_buildUnit_view").checked = false;
  }
  else {
    console.log("selected.value is " +selected.value);
    document.getElementById("selectedInfo_buildUnit_view").checked = true;
  }

  // 3. get color
  for(i=0; i<buildUnitArray.length; ++i) {
    if(buildUnitArray[i].name == buildUnit_name) {
      document.getElementById("selectedInfo_buildUnit_color").value = buildUnitArray[i].Color;
    }
  }
}

function toggleView_buildUnit() {
  var select = document.getElementById("select_buildUnit");
  var selected = select[select.selectedIndex];

  var current_check = document.getElementById("selectedInfo_buildUnit_view").checked;

  if(current_check===false)
    selected.value = 0;
  else 
    selected.value = 1;

  updateShow_buildUnit();
}

function updateShow_buildUnit() {
  var options = document.getElementById("select_buildUnit");
  var concealNotChecked = document.getElementById("onlyViewCheckedBuildUnit").checked;
  var node_visible;

  myDiagram.nodes.each(function(node){  
    if(concealNotChecked) {
      node_visible = false;
      if(options.length==0) node_visible = false;
      else {        
        for(i=0; i<options.length; ++i) {
          if(node.data.buildUnit == options[i].text) {
            if(options[i].value == 1) {
              addLog("updateShow_buildUnit(): There are the same build unit name and visible: "+node.data.buildUnit);
              node_visible = true;
            }
          }
        }  
        if(node.name=="FACTORY" && notAssigned_buildUnit(node.data.buildUnit)) node_visible = true;     
      }
    } else {
      node_visible = true;
    }

    node.visible = node_visible;
  });
}

function updateColor_buildUnit() {
  console.log("updateColor_buildUnit()");

  var currentTab;
  if(document.getElementById("SchematicTab").style.display === "block") currentTab = "SchematicTab";
  else if(document.getElementById("JsonTab").style.display === "block") currentTab = "JsonTab";
  else if(document.getElementById("BuildUnitTab").style.display === "block") currentTab = "BuildUnitTab";
  //else if(document.getElementById("SthreadTab").style.display === "block") currentTab = "SthreadTab";

//   var buildUnit_name;
//   var buildUnit_color;
//   var buildUnit_color_defualt = "white";

//   var i;
//   for(i=0; i<buildUnitArray.length; i++) {
//     buildUnit_name = buildUnitArray[i].name;
//     buildUnit_color = buildUnitArray[i].Color;
//     console.log(buildUnit_name + ", " + buildUnit_color);

    /*
    myDiagram.nodes.each(function(node){ 
      if(node.data.BuildUnit === buildUnit_name) {

        var shape = node.findObject("SHAPE");

        // change color of the component
        if(currentTab === "BuildUnitTab") shape.fill = buildUnit_color;
        else shape.fill = buildUnit_color_defualt;

        console.log("change color of "+node.data.key+" to "+shape.fill);
      }     
    });
    */
    // myDiagram_buildUnit.nodes.each(function(node){ 
    //   if(node.data.buildUnit === buildUnit_name) {
    //     if(node.name === "SOURCE"
    //       || node.name === "SINK"
    //       || node.name === "PROCESSING"
    //       || node.name === "FUSION") {
    //       var shape = node.findObject("SHAPE");
    //       // change color of the component
    //       shape.fill = buildUnit_color;
    //       console.log("change color of "+node.data.key+" to "+shape.fill);
    //     } else if(node.name === "FACTORY") {
    //       var shape = node.findObject("SHAPE");
    //       shape.stroke = buildUnit_color;
    //       console.log("change color of "+node.data.key+" to "+shape.fill);
    //     }       
    //   }     
    // });
//   }
}

function setBuildUnit_color() {
  console.log("setBuildUnit_color()");
  var select = document.getElementById("select_buildUnit");
  var selected = select[select.selectedIndex];
  if(selected===undefined) return;
  var buildUnit_name = selected.text;

  var i;
  for(i=0; i<buildUnitArray.length; ++i) {
    if(buildUnitArray[i].name == buildUnit_name) {
      buildUnitArray[i].Color = document.getElementById("selectedInfo_buildUnit_color").value;
    }
  }
  updateColor_buildUnit();
}

</script>

<script>

function addFusionOperator_rule() {
  var options = document.getElementById("select_fusionOperator_rule");
  var new_option = document.createElement("option");

  var new_ruleName = document.getElementById("newName_fusionOperator_rule").value;
  new_option.text = new_ruleName;
  new_option.value = "";

  if(new_option.text === null || new_option.text === undefined || new_option.text === "") {
    addLog("There are no fusion rule name");
    return;   
  }

  for(i=0; i<options.length; ++i) {
    if(new_option.text == options[i].text) {
      addLog("There are the same fusion rule name: "+new_option.text);
      return;    
    }
  }

  addLog("Add new fusion rule");
  options.add(new_option);

  // add buildUnit item to json format array
  //var json_fusionOperator = {};
  //buildUnitArray.push(json_buildUnit);
  //console.log(buildUnitArray);
}

function removeFusionOperator_rule() {
  var select = document.getElementById("select_fusionOperator_rule");
  var selected = select[select.selectedIndex];

  var ruleName = selected.text;

  document.getElementById("select_fusionOperator_optionalNum").value = "";

  select.remove(select.selectedIndex);
  //updateStates(myDiagram);

  // remove buildUnit item to json format array
  //var i;
  //var removing_buildUnit;
  //for(i=0; i<buildUnitArray.length; ++i) {
  //  if(buildUnitArray[i].name == buildUnitName) {
  //    delete buildUnitArray[i];
  //  }
  //}
  //console.log(buildUnitArray);

}

function infoFusionOperator_rule() {
  var select = document.getElementById("select_fusionOperator_rule");
  var selected = select[select.selectedIndex];

  document.getElementById("selectedInfo_fusionOperator_rule_name").value = selected.text;
  document.getElementById("selectedInfo_fusionOperator_rule_optionalNum").value = selected.value;
}

function getInputPorts_fusionOpertor() {
  //TODO

  var node = myDiagram.findNodeForKey("Alpha");
}

function setOptionalNum_fusionOperator() {
  var select = document.getElementById("select_fusionOperator_rule");
  var selected = select[select.selectedIndex];

  var optionNum = document.getElementById("selectedInfo_fusionOperator_rule_optionalNum");

  selected.value = optionNum.value;
}

</script>


<script>

function toggleBuildUnitWindow() {
  //console.log("toggleBuildUnitWindow()");

  var buildUnitWindow = document.getElementById("infoDraggable_buildUnit");
  var visible = buildUnitWindow.style.visibility;

  if(visible === "visible") buildUnitWindow.style.visibility = "hidden";
  else buildUnitWindow.style.visibility = "visible";
}

function toggleFusionOperatorWindow() {
  //console.log("toggleFusionOperatorWindow()");

  var fusionOperatorWindow = document.getElementById("infoDraggable_fusionOperator");
  var visible = fusionOperatorWindow.style.visibility;

  if(visible === "visible") fusionOperatorWindow.style.visibility = "hidden";
  else fusionOperatorWindow.style.visibility = "visible";
}


</script>


<script>
  function openTab(evt, tabName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    document.getElementById(tabName).style.display = "block";
    if(tabName === "SchematicTab") {
      updateSchematicViewer();
      document.getElementById("overviewDiv").style.display = "block";
    } else if(tabName === "JsonTab") {
      updateJsonViewer();
      document.getElementById("overviewDiv").style.display = "block";
    } else if(tabName === "BuildUnitTab") {
      updateBuildUnitViewer();
      document.getElementById("overviewDiv_buildUnit").style.display = "block";
    } 
    // else if(tabName === "SthreadTab") {
    //   document.getElementById("overviewDiv_sthread").style.display = "block";
    // }

    evt.currentTarget.className += " active";

  }

  function updateSchematicViewer() {
    //updateColor_buildUnit();
  }

  function updateJsonViewer() {
    var string_splashModel = SplashModelToString();
    document.getElementById("jsonViewer").innerHTML = string_splashModel;
  }

  function updateBuildUnitViewer() {
    console.log("updateBuildUnitViewer()");
    myDiagram_buildUnit.model = myDiagram.model;
    // updateColor_buildUnit();
  }

  function updateSthreadViewer() {
    console.log("updateSthreadViewer()");
    myDiagram_sthread_component.requestUpdate();
    myDiagram_sthread_sthread.requestUpdate();

  }

  function updateSthreadViewer_component(component_model) {
    console.log("updateSthreadViewer_component()");

    console.log(component_model);
    myDiagram_sthread_component.model = go.Model.fromJson(component_model);
    //updateSthreadViewer_empty();
    myDiagram_sthread_component.requestUpdate();
  }

    function updateSthreadViewer_sthread(port_model) {
    console.log("updateSthreadViewer_sthread()");

    // TODO
    myDiagram_sthread_sthread.model = go.Model.fromJson(port_model);
    myDiagram_sthread_sthread.requestUpdate();
  }


  function forceSelectTab(tabName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";

    var buttonID = tabName.replace("Tab","Button");
    document.getElementById(buttonID).className += " active";

    console.log("forceSelectTab");
  }
</script>

</head>
  <body style="margin-top: 0;">
  <div class="container">
    <div id="programTitle"></div>
    <div id="programName" style="display:none">RTOS Splash Schematic Editor</div>
    <div id="currentFile" style="display:none">(NEW_FILENAME)</div>
    <div id="version" style="display:none">v0.7.2</div>
    	<div id="menuBar" style="z-index: 10">
      <ul id="nav">
        <li><a href="#">File</a>
          <ul>
            <li><a href="#" onclick="newDocument()">New</a></li>
            <li>
            	<input id="fileOpenMenu" type="file" accept=".json" name="files[]" style="display:none"/>
              <a href="#" onclick="openDocument()" >Open</a>
            </li>
            <li><a href="#" onclick="saveDocument()">Save (Download)</a></li>
            <li>
              <output id="fileSaveAsMenu" download="data.json" type="file"/>
              <a href="#" onclick="saveAsDocument()">Save As (Download As) </a>
            </li>
          </ul>
        </li>
        <li><a href="#">Edit</a>
          <ul>
<!--             <li><a id="Rename" href="#" onclick="rename()">Rename</a></li>
            <li><a id="A1" href="#" onclick="myDiagram.commandHandler.undo()">Undo</a></li>
            <li><a id="Redo" href="#" onclick="myDiagram.commandHandler.redo()">Redo</a></li>
            <li><a id="Cut" href="#" onclick="myDiagram.commandHandler.cutSelection()">Cut</a></li>
            <li><a id="Copy" href="#" onclick="myDiagram.commandHandler.copySelection()">Copy</a></li>
            <li><a id="Paste" href="#" onclick="myDiagram.commandHandler.pasteSelection()">Paste</a></li>
            <li><a id="Delete" href="#" onclick="myDiagram.commandHandler.deleteSelection()">Delete</a></li>
            <li><a id="SelectAll" href="#" onclick="myDiagram.commandHandler.selectAll()">Select All</a></li> -->
          </ul>
        </li>
        <li><a href="#">Align</a>
          <ul >
<!--             <li><a id="AlignLeft" href="#" onclick="myDiagram.commandHandler.alignLeft()">Left Sides</a></li>
            <li><a id="AlignRight" href="#" onclick="myDiagram.commandHandler.alignRight()">Right Sides</a></li>
            <li><a id="AlignTop" href="#" onclick="myDiagram.commandHandler.alignTop()">Tops</a></li>
            <li><a id="AlignBottom" href="#" onclick="myDiagram.commandHandler.alignBottom()">Bottoms</a></li>
            <li><a id="AlignCenterX" href="#" onclick="myDiagram.commandHandler.alignCenterX()">Center X</a></li>
            <li><a id="AlignCenterY" href="#" onclick="myDiagram.commandHandler.alignCenterY()">Center Y</a></li> -->
          </ul>
        </li>

        <!-- <li><a href="#">Syntax</a>
          <ul >
            <li><a id="SyntaxBuildUnit" href="#" onclick="checkSyntax_buildUnit()">Build Unit</a></li>
          </ul>
        </li> -->

        <!-- <li><a href="#">View</a>
          <ul >
            <li><a id="ViewBuildUnit" href="#" onclick="toggleBuildUnitWindow()">Build Unit Window</a></li>
            <li><a id="ViewFusionOperator" href="#" onclick="toggleFusionOperatorWindow()">Fusion Operator Window</a></li>
          </ul>
        </li> -->

        <li><a href="#">Options</a>
          <ul>
            <li><a href="#"><input id="grid" type="checkbox" name="options" value="grid" checked="checked" onclick="updateGridOption()">Grid</a></li>
            <li><a href="#"><input id="guidelines" type="checkbox" name="options" value="0" checked="checked" onclick="updateGuidelinesOption()">Guidelines</a></li>
            <li><a href="#"><input id="snap" type="checkbox" name="options" value="0" checked="checked" onclick="updateSnapOption()">Snapping</a></li>
<!--             <li><a href="#">Arrow Keys >></a>
              <form >
                <ul>
                  <li><a href="#"><input type="radio" name="arrow" id="move" onclick="arrowMode()" checked="checked">Move</a></li>
                  <li><a href="#"><input type="radio" name="arrow" id="select" onclick="arrowMode()">Select</a></li>
                  <li><a href="#"><input type="radio" name="arrow" id="scroll" onclick="arrowMode()">Scroll</a></li>
                </ul>
              </form>
            </li> -->
          </ul>
        </li>
        <li><a href="#">Help</a>
          <ul >
            <li><a id="aboutMenu" href="#" onclick="developmentInfo()">About</a></li>
          </ul>
        </li>
      </ul>
    </div><!--END menu bar -->
  </div>
  
  <div id="devInfo" class="aboutBox">
    <div class="aboutBox-content">      
      <span class="closeAboutBox" onclick="aboutClose()">&times;</span>
      <h1>RTOS Splash Schematic Editor</h1>
      <hr>
      <a>
        &emsp; A graphical programming framework named <splashHighlight>Splash</splashHighlight> that explicitly addresses the programming challenges that arise during the development of an autonomous machine. We set four design goals to solve these challenges. First, Splash must provide an effective programming abstraction that supports the stream processing of an autonomous machine. Second, it must enable programmers to specify genuine, end-to-end timing constraints and monitor the violation of such constraints. Third, it must support exception handling, mode change and sensor fusion. Finally, it must support performance optimization and tuning during system implementation[1].        
      </a>
      <br></br>
      <div style="text-align:center">
        <img id="logo_rtoslab" alt="rtoslab logo" src="../image/rtoslab_logo.png">
        <img id="logo_splash" alt="splash logo" src="../image/splash1-14.png">
      </div>

      <hr>
      <a style="font-size: 13px">
        [1] Soonhyun Noh and Seongsoo Hong, "Splash: A Graphical Programming Framework for an Autonomous Machine," The 16th International Conference on Ubiquitous Robots (UR 2019) , pp. 660-666, Jun 2019
      </a>
      <a href="http://redwood.snu.ac.kr" target="_blank">
        <p>http://redwood.snu.ac.kr</p>
      </a>
    </div>
  </div>

  <div id="SchematicTab" class="tabcontent" style="display:block; padding: 0px">
    <div id="CanvasAndSidebar" style="width: 100%; height: 645px; display: flex;  justify-content: space-between;">
      <div id="SplashCanvas" style="padding: 0px"></div>
      <div id="sidebar">
        <div class="sidebar__inner">
          <div id="palette"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="JsonTab" class="tabcontent" style="padding: 0px; height: 645px;" >
    <textarea readonly id="jsonViewer" style="width: 100%; height: 645px;resize: none; ">
    </textarea>
  </div>
  
  <div id="BuildUnitTab" class="tabcontent" style="padding: 0px">
        <div id="buildUnitCanvas">
            <div id="buildUnitViewer"></div>
            <div id="resizeBorder"></div>
            <div id="selectionPaneWrapper">
                <div id="selectionPaneTitle"></div>
                <div id="selectionPane"></div>
            </div>
            
        </div>  
        
  </div>

  <div id="SthreadTab" class="tabcontent" style="padding: 0px">
    <div id="SthreadCanvas_component" style="width: 100%; height: 200px; display: flex;  justify-content: space-between;"> 
      <div id="SthreadViewer_component" style="padding: 0px"></div>
    </div>
    <div id="SthreadCanvas_sthread" style="width: 100%; height: 445px; display: flex;  justify-content: space-between; background-color: #DFDADA;">
      <div id="SthreadViewer_sthread" style="padding: 0px"></div>
      <div id="sidebar_sthread">
        <div class="sidebar_sthread__inner">
          <div id="palette_sthread"></div>
        </div>
      </div>
    </div>  
  </div>

  <div class="tab">
    <button id="SchematicButton" class="tablinks active" onclick="openTab(event, 'SchematicTab')">Schematic</button>
    <button id="BuildUnitButton" class="tablinks" onclick="openTab(event, 'BuildUnitTab')">BuildUnit</button>
    <button id="JsonButton" class="tablinks" onclick="openTab(event, 'JsonTab')">Json</button>
    <!-- <button id="SthreadButton" class="tablinks" onclick="openTab(event, 'SthreadTab')">Sthread</button> -->
  </div>


  <div id="infoDraggable_buildUnit" class="draggable" style="z-index: 9; visibility: hidden; display: inline-block; vertical-align: top; padding: 5px; top: 55px; left: 20px;  height: 280px; width: 300px">
    <div id="infoDraggableHandle_buildUnit" class="handle">Build Unit</div>
      <div>
        <div id="myInfo_buildUnit"></div>
          <form style="position: absolute; left: 0px top: 0px;">
            <select id="select_buildUnit" size="8" onchange="infoBuildUnit()" style="width: 100px; height: 200px">
            </select>
          </form>
          <input type="text" id="newName_buildUnit" style="position: absolute; left: 5px; top: 225px; width: 100px"><br>
          <button type="button" onclick="addBuildUnit()" style="position: absolute; left: 5px; top: 247px; width: 140px;">Add BuildUnit</button>
          <button type="button" onclick="removeBuildUnit()" style="position: absolute; left: 147px; top: 247px; width: 140px;">Remove BuildUnit</button>
          <div style="font-size: 13px; position: absolute; left: 118px; top: 32px;">Name:</div>
          <input type="text" id="selectedInfo_buildUnit_name" readonly style="width: 125px; position: absolute; left: 160px; top: 30px;">
          <div  style="font-size: 13px; position: absolute; left: 118px; top: 57px;">Color:</div> 
          <input type="color" id="selectedInfo_buildUnit_color" value="#ffffff" onchange="setBuildUnit_color()" style="position: absolute; left: 160px; top: 55px;">
          <div  style="font-size: 13px; position: absolute; left: 118px; top: 82px;">View:</div> 
          <input type="checkbox" id="selectedInfo_buildUnit_view" onclick="toggleView_buildUnit()" style="position: absolute; left: 156px; top: 82px;">

          
            
          </form>
          <input type="checkbox" id="onlyViewCheckedBuildUnit" onclick="updateShow_buildUnit()" style="position: absolute; left: 110px; top: 220px;">
          <div  style="font-size: 13px; position: absolute; left: 135px; top: 215px;">Only view checked <br> build unit</div> 

      </div>
  </div>

  <div id="infoDraggable_fusionOperator" class="draggable" style="z-index: 9; visibility: hidden; display: inline-block; vertical-align: top; padding: 5px; top: 350px; left: 20px;  height: 240px; width: 300px">
    <div id="infoDraggableHandle_fusionOperator" class="handle">Fusion Operator</div>
      <div>
        <div id="myInfo_fusionOperator"></div>
          <div style="font-size: 13px; position: absolute; left: 10px; top: 25px;">key :</div>
          <input type="text" id="selected_fusionOperator" readonly style="width: 242px; position: absolute; left: 45px; top: 23px;">
          <form style="position: absolute; left: 0px top: 0px;">
            <select id="select_fusionOperator_rule" size="8" onchange="infoFusionOperator_rule()" style="position: absolute; height: 140px; width: 110px; top: 20px;" >
            </select>
          </form>
          <input type="text" id="newName_fusionOperator_rule" style="position: absolute; left: 5px; top: 185px; width: 110px"><br>
          <button type="button" onclick="addFusionOperator_rule()" style="position: absolute; left: 5px; top: 207px; width: 140px;">Add FusionRule</button>
          <button type="button" onclick="removeFusionOperator_rule()" style="position: absolute; left: 147px; top: 207px; width: 140px;">Remove FusionRule</button>
          <div style="font-size: 13px; position: absolute; left: 125px; top: 50px;">Name:</div>
          <input type="text" id="selectedInfo_fusionOperator_rule_name" readonly style="width: 117px; position: absolute; left: 170px; top: 45px;">
          <div style="font-size: 13px; position: absolute; left: 125px; top: 70px;">Optional #:</div>
          <input type="text" id="selectedInfo_fusionOperator_rule_optionalNum" style="width: 55px; position: absolute; left: 190px; top: 67px;">
          <button type="button" onclick="setOptionalNum_fusionOperator()" style="position: absolute; left: 247px; top: 67px; width: 40px;">Set</button>
          <div style="font-size: 13px; position: absolute; left: 125px; top: 93px;">Correlation:</div>
          <input type="text" id="selectedInfo_fusionOperator_rule_correlation" style="width: 50px; position: absolute; left: 195px; top: 89px;">
          <button type="button" onclick="setCorrelation_fusionOperator()" style="position: absolute; left: 247px; top: 89px; width: 40px;">Set</button>
          <div style="font-size: 13px; position: absolute; left: 125px; top: 113px;">InputPort key:</div>
          <input type="text" id="selected_inputPort_fusionOperator" readonly style="width: 167px; position: absolute; left: 120px; top: 130px;">
          <input type="radio" name="inputType" value="man" style="position: absolute; left: 115px; top: 153px;">
          <div style="font-size: 10px; position: absolute; left: 140px; top: 157px;">Mandatory</div>
          <input type="radio" name="inputType" value="opt" style="position: absolute; left: 115px; top: 170px;">
          <div style="font-size: 10px; position: absolute; left: 140px; top: 174px;">Optional</div>
          <input type="radio" name="inputType" value="none" style="position: absolute; left: 115px; top: 187px;">
          <div style="font-size: 10px; position: absolute; left: 140px; top: 191px;">Don't care</div>


<!--           <input type="text" id="newName_buildUnit" style="position: absolute; left: 5px; top: 145px; width: 100px"><br>
          <button type="button" onclick="addBuildUnit()" style="position: absolute; left: 5px; top: 167px; width: 100px;">Add BuildUnit</button>
          <button type="button" onclick="removeBuildUnit()" style="position: absolute; left: 110px; top: 167px; width: 130px;">Remove BuildUnit</button>
          <div style="font-size: 13px; position: absolute; left: 118px; top: 32px;">Name:</div>
          <input type="text" id="selectedInfo_buildUnit_name" readonly style="width: 125px; position: absolute; left: 160px; top: 30px;">
          <div  style="font-size: 13px; position: absolute; left: 118px; top: 57px;">Veiw:</div> 
          <input type="checkbox" id="selectedInfo_buildUnit_view" onclick="toggleView_buildUnit()" style="position: absolute; left: 156px; top: 57px;"> 

          <div  style="font-size: 13px; position: absolute; left: 135px; top: 135px;">Only view checked <br> build unit</div> 
          <input type="checkbox" id="onlyViewCheckedBuildUnit" onclick="updateShow_buildUnit()" style="position: absolute; left: 110px; top: 140px;">  -->
        
      </div>
  </div>



  <div class="container clearfix">
    <div id="OverallPanel" style="width: 100%; position: relative; overflow: hidden;">

      <div id="infoPanel" style="width: 100%; height: 20%; display: flex; justify-content: space-between">
        <div id="consolePanel" style="float:left; width: 40%; height: 100%; min-height: 200px; text-align:center;">
          <div class="handle">Log Console</div>
          <textarea readonly id="splash_logConsol" style="width: 100%; height: 200px; resize: none;"></textarea>
        </div>
        <div id="propertyPanel" style="float:left; width: 40%; height: 100%; min-height: 200px; text-align:center;">
          <div class="handle">Property</div>
          <div id="propertyTextField">
            <div id="BasicProperty" style="float:left; width: 50%; height: 100%; min-height: 170px; text-align:center;">
              <div class="handle">Language Construct Attribute</div>
              <div id="splashInspectorDiv" class="inspector" style="width: 100%; height: 150px; resize: none; overflow-y: scroll;"></div>
            </div>
            <div id="ConstraintsProperty" style="float:left; width: 50%; height: 100%; min-height: 170px; text-align:center;">
              <div class="handle">Node/Link Property</div>
              <div id="splashInspectorDiv2" class="inspector" style="width: 100%; height: 150px; resize: none; overflow-y: scroll;"></div>             
            </div> 
          </div>
          <button type="button" onclick="updateProperty()" style="width: 100%; height: 28px; ">Confirm</button>
        </div>

        <div id="overviewPanel" style="float:right; width: 20%; height: 100%; min-height: 200px; text-align:center;">
          <div class="handle">Overview</div>
          <div id="overviewDiv" class="tabcontent" style="display:block; border:solid 1px gray; width: 100%; height:200px;"></div>
          <div id="overviewDiv_buildUnit" class="tabcontent" style="border:solid 1px gray; width: 100%; height:200px;"></div>
          <div id="overviewDiv_sthread" class="tabcontent" style="border:solid 1px gray; width: 100%; height:200px;"></div>
        </div>
      </div>
    </div>
  </div>  
  
  <!-- <script type="text/javascript"> -->
      <!-- var a = new StickySidebar('#sidebar', { -->
      <!-- topSpacing: 20, -->
      <!-- bottomSpacing: 20, -->
      <!-- containerSelector: '.container', -->
      <!-- innerWrapperSelector: '.sidebar__inner' -->
    <!-- }); -->
  <!-- </script> -->

</body>
</html>